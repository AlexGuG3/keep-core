package chain

import (
	"math/big"
)

// DKGResult is a result of distributed key generation protocol.
//
// Success means that the protocol execution finished with acceptable number of
// disqualified or inactive members. The group of remaining members should be
// added to the signing groups for the threshold relay.
//
// Failure means that the group creation could not finish, due to either the number
// of inactive or disqualified participants, or the presented results being
// disputed in a way where the correct outcome cannot be ascertained.
type DKGResult struct {
	// Result type of the protocol execution. True if success, false if failure.
	Success bool
	// Group public key generated by protocol execution.
	GroupPublicKey *big.Int
	// Disqualified members IDs.
	Disqualified []bool
	// Inactive members IDs.
	Inactive []bool
}

// Equals checks if two published results are equal.
func (pr *DKGResult) Equals(pr2 *DKGResult) bool {
	if pr == nil || pr2 == nil {
		return pr == pr2
	}
	if pr.Success != pr2.Success {
		return false
	}
	if !bigIntEquals(pr.GroupPublicKey, pr2.GroupPublicKey) {
		return false
	}
	if !boolSlicesEqual(pr.Disqualified, pr2.Disqualified) {
		return false
	}
	if !boolSlicesEqual(pr.Inactive, pr2.Inactive) {
		return false
	}
	return true
}

// bigIntEquals checks if two big.Int values are equal.
func bigIntEquals(expected *big.Int, actual *big.Int) bool {
	if expected != nil && actual != nil {
		return expected.Cmp(actual) == 0
	}
	return expected == nil && actual == nil
}

// boolSlicesEqual checks if two slices of bool are equal. Slices need to have
// the same length and have the same order of entries.
func boolSlicesEqual(expectedSlice []bool, actualSlice []bool) bool {
	if len(expectedSlice) != len(actualSlice) {
		return false
	}
	for i := range expectedSlice {
		if expectedSlice[i] != actualSlice[i] {
			return false
		}
	}
	return true
}
