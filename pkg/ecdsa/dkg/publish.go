package dkg

import (
	"bytes"
	"fmt"
	"github.com/ipfs/go-log"
	"math/big"

	"github.com/keep-network/keep-core/pkg/chain"
	"github.com/keep-network/keep-core/pkg/net"
	"github.com/keep-network/keep-core/pkg/protocol/group"
	"github.com/keep-network/keep-core/pkg/protocol/state"
	"github.com/keep-network/keep-core/pkg/subscription"
)

// TODO: Move structure and interfaces to appropriate files.

// DKGStartedEvent represents a DKG start event.
type DKGStartedEvent struct {
	Seed        *big.Int
	BlockNumber uint64
}

// DKGResult is a result of distributed key generation protocol.
//
// If the protocol execution finishes with an acceptable number of disqualified
// or inactive members, the group with remaining list of honest members will
// be added to the signing groups list for the random beacon.
//
// Otherwise, group creation will not finish, which will be due to either the
// number of inactive or disqualified participants, or the results (signatures)
// being disputed in a way where the correct outcome cannot be ascertained.
type DKGResult struct {
	// Group public key generated by the protocol execution, empty if the protocol failed.
	GroupPublicKey []byte
	// Misbehaved members are all members either inactive or disqualified.
	// Misbehaved members are represented as a slice of bytes for optimizing
	// on-chain storage. Each byte is an inactive or disqualified member index.
	Misbehaved []byte
}

// DKGResultHash is a 256-bit hash of DKG Result. The hashing algorithm should
// be the same as the one used on-chain.
type DKGResultHash [hashByteSize]byte

const hashByteSize = 32

// DKGResultsVotes is a map of votes for each DKG Result.
type DKGResultsVotes map[DKGResultHash]int

// Equals checks if two DKG results are equal.
func (r *DKGResult) Equals(r2 *DKGResult) bool {
	if r == nil || r2 == nil {
		return r == r2
	}
	if !bytes.Equal(r.GroupPublicKey, r2.GroupPublicKey) {
		return false
	}
	if !bytes.Equal(r.Misbehaved, r2.Misbehaved) {
		return false
	}

	return true
}

// DKGResultHashFromBytes converts bytes slice to DKG Result Hash. It requires
// provided bytes slice size to be exactly 32 bytes.
func DKGResultHashFromBytes(bytes []byte) (DKGResultHash, error) {
	var hash DKGResultHash

	if len(bytes) != hashByteSize {
		return hash, fmt.Errorf("bytes length is not equal %v", hashByteSize)
	}
	copy(hash[:], bytes[:])

	return hash, nil
}

// DKGResultSubmissionEvent represents a DKG result submission event. It is emitted
// after a submitted DKG result is positively validated on the chain. It contains
// the index of the member who submitted the result and a final public key of
// the group.
type DKGResultSubmissionEvent struct {
	MemberIndex    uint32
	GroupPublicKey []byte
	Misbehaved     []uint8

	BlockNumber uint64
}

// GroupMemberIndex is an index of a wallet registry group member.
// Maximum value accepted by the chain is 255.
type GroupMemberIndex = uint8

type Chain interface {
	// SubmitDKGResult sends DKG result to a chain, along with signatures over
	// result hash from group participants supporting the result.
	// Signatures over DKG result hash are collected in a map keyed by signer's
	// member index.
	SubmitDKGResult(
		participantIndex GroupMemberIndex,
		dkgResult *DKGResult,
		signatures map[GroupMemberIndex][]byte,
	) error
	// IsGroupRegistered checks if group with the given public key is registered
	// on-chain.
	IsGroupRegistered(groupPublicKey []byte) (bool, error)
	// OnDKGResultSubmitted registers a callback that is invoked when an on-chain
	// notification of a new, valid submitted result is seen.
	OnDKGResultSubmitted(
		func(event *DKGResultSubmissionEvent),
	) subscription.EventSubscription
	// Signing returns the chain's signer.
	Signing() chain.Signing
	// CalculateDKGResultHash calculates 256-bit hash of DKG result in standard
	// specific for the chain. Operation is performed off-chain.
	CalculateDKGResultHash(dkgResult *DKGResult) (DKGResultHash, error)
}

// TODO: Description
func Publish(
	logger log.StandardLogger,
	memberIndex group.MemberIndex,
	dkgGroup *group.Group,
	membershipValidator *group.MembershipValidator,
	submissionConfig *SubmissionConfig,
	result *Result,
	channel net.BroadcastChannel,
	chain Chain,
	blockCounter chain.BlockCounter,
	startBlockHeight uint64,
) error {
	signingMember := NewSigningMember(
		logger,
		memberIndex,
		dkgGroup,
		membershipValidator,
		submissionConfig,
	)

	initialState := &resultSigningState{
		channel:                 channel,
		chain:                   chain,
		blockCounter:            blockCounter,
		member:                  signingMember,
		result:                  convertToChainResult(result),
		signatureMessages:       make([]*dkgResultHashSignatureMessage, 0),
		signingStartBlockHeight: startBlockHeight,
	}

	stateMachine := state.NewMachine(logger, channel, blockCounter, initialState)

	lastState, _, err := stateMachine.Execute(startBlockHeight)
	if err != nil {
		return err
	}

	_, ok := lastState.(*resultSubmissionState)
	if !ok {
		return fmt.Errorf("execution ended on state %T", lastState)
	}

	return nil
}
