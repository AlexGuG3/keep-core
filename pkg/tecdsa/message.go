package tecdsa

import (
	"github.com/keep-network/keep-core/pkg/tecdsa/commitment"
	"github.com/keep-network/keep-core/pkg/tecdsa/curve"
	"github.com/keep-network/keep-core/pkg/tecdsa/zkp"
	"github.com/keep-network/paillier"
)

// PublicKeyShareCommitmentMessage is a message payload that carries signer's
// commitment for a public DSA key share the signer generated.
// It's the very first message exchanged between signers during the T-ECDSA
// distributed key generation process. The message is expected to be broadcast
// publicly.
type PublicKeyShareCommitmentMessage struct {
	signerID string

	commitment *commitment.TrapdoorCommitment
}

// KeyShareRevealMessage is a message payload that carries the sender's share of
// public and secret DSA key during T-ECDSA distributed key generation as well
// as proofs of correctness for the shares. Sender's share is encrypted with
// (t, n) Paillier threshold key. The message is expected to be broadcast
// publicly.
type KeyShareRevealMessage struct {
	signerID string

	secretKeyShare *paillier.Cypher
	publicKeyShare *curve.Point

	publicKeyDecommitmentKey *commitment.DecommitmentKey
	secretKeyProof           *zkp.DsaPaillierKeyRangeProof
}

// isValid checks secret and public key share against zero knowledge range proof
// shipped alongside them as well as commitment generated by the signer in the
// first phase of the key generation process. This function should be called
// for each received KeyShareRevealMessage before it's combined to a final key.
func (msg *KeyShareRevealMessage) isValid(
	commitment *commitment.TrapdoorCommitment,
	zkpParams *zkp.PublicParameters,
) bool {
	commitmentValid := commitment.Verify(
		msg.publicKeyDecommitmentKey, msg.publicKeyShare.Bytes(),
	)

	zkpValid := msg.secretKeyProof.Verify(
		msg.secretKeyShare, msg.publicKeyShare, zkpParams,
	)

	return commitmentValid && zkpValid
}

// SignRound1Message is a message produced by each `Signer` as a result of
// executing the first round of T-ECDSA signing algorithm.
type SignRound1Message struct {
	signerID string

	secretKeyFactorCommitment *commitment.TrapdoorCommitment // C_1i
}

// SignRound2Message is a message produced by each `Signer` as a result of
// executing the second round of T-ECDSA signing algorithm.
type SignRound2Message struct {
	signerID string

	secretKeyRandomFactorShare     *paillier.Cypher            // u_i = E(ρ_i)
	secretKeyMultipleShare         *paillier.Cypher            // v_i = E(ρ_i * x)
	secretKeyFactorDecommitmentKey *commitment.DecommitmentKey // D_1i

	secretKeyFactorProof *zkp.DsaPaillierSecretKeyFactorRangeProof // PI_1i
}

// isValid checks secret key random factor share and secret key multiple share
// against the zero knowledge proof shipped alongside them as well as validates
// commitment generated by signer in the first round.
func (msg *SignRound2Message) isValid(
	commitment *commitment.TrapdoorCommitment, // C_1i
	dsaSecretKey *paillier.Cypher, // E(x)
	zkpParams *zkp.PublicParameters,
) bool {
	commitmentValid := commitment.Verify(
		msg.secretKeyFactorDecommitmentKey,
		msg.secretKeyRandomFactorShare.C.Bytes(),
		msg.secretKeyMultipleShare.C.Bytes(),
	)

	zkpValid := msg.secretKeyFactorProof.Verify(
		msg.secretKeyMultipleShare, dsaSecretKey, msg.secretKeyRandomFactorShare, zkpParams,
	)

	return commitmentValid && zkpValid
}

// SignRound3Message is a message produced by each `Signer` as a result of
// executing the third round of T-ECDSA signing algorithm.
type SignRound3Message struct {
	signerID string

	signatureFactorCommitment *commitment.TrapdoorCommitment // C_2i
}

// SignRound4Message is a message produced by each `Signer` as a result of
// executing the fourth round of T-ECDSA signing algorithm.
type SignRound4Message struct {
	signerID string

	signatureRandomMultiplePublicShare *curve.Point                // r_i = g^{k_i}
	signatureUnmaskShare               *paillier.Cypher            // w_i = E(k_i * ρ + c_i * q)
	signatureFactorDecommitmentKey     *commitment.DecommitmentKey // D_2i

	signatureFactorProof *zkp.EcdsaSignatureFactorRangeProof // PI_2i
}

// isValid checks the signature random multiple public share and signature
// unmask share against the zero knowledge proof shipped alongside them. It
// also validates commitment generated by the signer in the third round.
func (msg *SignRound4Message) isValid(
	signatureFactorCommitment *commitment.TrapdoorCommitment, // C_2i
	secretKeyRandomFactor *paillier.Cypher, // u = E(ρ)
	zkpParams *zkp.PublicParameters,
) bool {
	commitmentValid := signatureFactorCommitment.Verify(
		msg.signatureFactorDecommitmentKey,
		msg.signatureRandomMultiplePublicShare.Bytes(),
		msg.signatureUnmaskShare.C.Bytes(),
	)

	zkpValid := msg.signatureFactorProof.Verify(
		msg.signatureRandomMultiplePublicShare,
		msg.signatureUnmaskShare,
		secretKeyRandomFactor,
		zkpParams,
	)

	return commitmentValid && zkpValid
}
