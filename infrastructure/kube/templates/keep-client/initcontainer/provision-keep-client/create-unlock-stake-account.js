
/*
We override transactionConfirmationBlocks and transactionBlockTimeout because they're
25 and 50 blocks respectively at default.  The result of this on small private testnets
is long wait times for scripts to execute.
*/
const web3_options = {
    defaultBlock: 'latest',
    defaultGas: 4712388,
    transactionBlockTimeout: 25,
    transactionConfirmationBlocks: 3,
    transactionPollingTimeout: 480
}
const Web3 = require('web3');
// ENV VARs sourced from InitContainer Dockerfile
const web3 = new Web3(new Web3.providers.HttpProvider(process.env.ETH_HOSTNAME + ":" + process.env.ETH_HOST_PORT), null, web3_options);
const fs = require('fs');
const toml = require('toml');
const tomlify = require('tomlify-j0.4');
const concat = require('concat-stream');

/*
Each <contract.json> file is sourced directly from the InitContainer.  Files are generated by
Truffle during contract and copied to the InitContainer image via Circle.
*/
const stakingProxyContractJsonFile = "/tmp/StakingProxy.json";
const stakingProxyContractParsed = JSON.parse(fs.readFileSync(stakingProxyContractJsonFile));
const stakingProxyContractAbi = stakingProxyContractParsed.abi;
// ENV VAR sourced from InitContainer Dockerfile
const stakingProxyContractAddress = stakingProxyContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const stakingProxyContract = new web3.eth.Contract(stakingProxyContractAbi, stakingProxyContractAddress);

// tokenStaking
const tokenStakingContractJsonFile = "/tmp/TokenStaking.json";
const tokenStakingContractParsed = JSON.parse(fs.readFileSync(tokenStakingContractJsonFile));
const tokenStakingContractAbi = tokenStakingContractParsed.abi;
const tokenStakingContractAddress = tokenStakingContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const tokenStakingContract = new web3.eth.Contract(tokenStakingContractAbi, tokenStakingContractAddress);

// keepToken
const keepTokenContractJsonFile = "/tmp/KeepToken.json";
const keepTokenContractParsed = JSON.parse(fs.readFileSync(keepTokenContractJsonFile));
const keepTokenContractAbi = keepTokenContractParsed.abi;
const keepTokenContractAddress = keepTokenContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const keepTokenContract = new web3.eth.Contract(keepTokenContractAbi, keepTokenContractAddress);

// Eth account that contracts are migrated against. ENV VAR sourced from Docker image.
const contract_owner = process.env.CONTRACT_OWNER_ETH_ACCOUNT_ADDRESS;

// Stake a target eth account
async function provisionKeepClient() {

  try {
    console.log("<<<<<<<<<<<< Unlocking Contract Owner Account " + contract_owner + " >>>>>>>>>>>>");
    // Transactions during staking are sent from contract_owner, must be unlocked before start.
    await unlockEthAccount(contract_owner, process.env.KEEP_CLIENT_ETH_ACCOUNT_PASSWORD);

    console.log("<<<<<<<<<<<< Provisioning Operator Account " + ">>>>>>>>>>>>")
    let operator_eth_account_password = process.env.KEEP_CLIENT_ETH_ACCOUNT_PASSWORD;
    let operatorAccount = await createEthAccount("operator");
    let operator = operatorAccount["address"];

    await createEthAccountKeyfile(operatorAccount["privateKey"], operator_eth_account_password);
    // We wallet add to make the local account available to web3 functions in the script.
    await web3.eth.accounts.wallet.add(operatorAccount["privateKey"]);
    console.log("Operator account provisioned!")

    console.log("<<<<<<<<<<<< Staking Operator Account " + operator + " >>>>>>>>>>>>")
    await stakeEthAccount(operator)

    console.log("<<<<<<<<<<<< Creating keep-client Config File >>>>>>>>>>>>")

  }
  catch(error) {
    console.error(error.message);
    throw error;
  }
};

async function stakeEthAccount(eth_account) {

  // ENV VAR sourced from Docker image.
  let magpie = process.env.CONTRACT_OWNER_ETH_ACCOUNT_ADDRESS;

  let contract_owner_signed = await web3.eth.sign(web3.utils.soliditySha3(contract_owner), eth_account);
  let contract_owner_signature = contract_owner_signed.signature;

  let signature = Buffer.from(contract_owner_signature.substr(2), 'hex');
  let delegation = '0x' + Buffer.concat([Buffer.from(magpie.substr(2), 'hex'), signature]).toString('hex');

  console.log("<<<<<<<<<<<< Checking if stakingProxy/tokenStaking Contracts Are Authorized >>>>>>>>>>>>");
  if (!await stakingProxyContract.methods.isAuthorized(tokenStakingContract.address).call({from: contract_owner}))
  {
    console.log("Authorizing stakingProxy/tokenStaking Contracts")
    await stakingProxyContract.methods.authorizeContract(tokenStakingContract.address).send({from: contract_owner}).then((receipt) => {
    console.log(JSON.stringify(receipt));
    })
  }
  console.log("stakingProxy/tokenStaking Contracts Authorized!");
  console.log("<<<<<<<<<<<< Staking Account: " + eth_account + " >>>>>>>>>>>>");
  await keepTokenContract.methods.approveAndCall(
    tokenStakingContract.address,
    formatAmount(1000000, 18),
    delegation).send({from: contract_owner}).then((receipt) => {
      console.log(JSON.stringify(receipt));
      console.log("Account " + eth_account + " staked!");
  });
}

async function createEthAccount(account_name) {

  let eth_account = await web3.eth.accounts.create();

  // We write to a file for later passage to the keep-client container
  fs.writeFile("/mnt/keep-client/config/eth_account_address", eth_account["address"], (error) => {
    if (error) throw error;
  });
  console.log(account_name + " Account "  + eth_account["address"] + " Created!");
  return eth_account
  }

// We are creating a local account.  We must manually generate a keyfile for use by the keep-client
async function createEthAccountKeyfile(eth_account_private_key, eth_account_password) {

  let eth_account_keyfile = await web3.eth.accounts.encrypt(eth_account_private_key, eth_account_password);

  // We write to a file for later passage to the keep-client container
  fs.writeFile("/mnt/keep-client/config/eth_account_keyfile", JSON.stringify(eth_account_keyfile), (error) => {
    if (error) throw error;
  });
  console.log("Keyfile generated!");
};

async function unlockEthAccount(eth_account, eth_account_password) {

  await web3.eth.personal.unlockAccount(eth_account, eth_account_password, 150000);
  console.log("Account " + eth_account + " unlocked!");
};

async function createKeepClientConfig(eth_account) {

  try {
    if ((process.env.INSTANCE_NAME).includes("bootstrap")) {
      fs.createReadStream('/tmp/keep-client-bootstrap-peer-template.toml', 'utf8').pipe(concat(function(data) {
        let parsedConfigFile = toml.parse(data);
        parsedConfigFile.ethereum.URL = "";
        parsedConfigFile.ethereum.URLRPC = "";
        parsedConfigFile.ethereum.ContractAddresses.KeepRandomBeacon = "";
        parsedConfigFile.ethereum.ContractAddresses.KeepGroup = "";
        parsedConfigFile.ethereum.ContractAddresses.Staking = "";
        fs.writeFile("/mnt/keep-client/config/keep-client-config.toml", tomlify.toToml(parsedConfigFile), (error) => {
          if (error) throw error;
        });
      }));
    } else {
      fs.createReadStream('/tmp/keep-client-standard-peer-template.toml', 'utf8').pipe(concat(function(data) {
        let parsedConfigFile = toml.parse(data);
        parsedConfigFile.ethereum.URL = "";
        parsedConfigFile.ethereum.URLRPC = "";
        parsedConfigFile.ethereum.account.Address = "";
        parsedConfigFile.ethereum.account.KeyFile = "/mnt/keep-client/config/eth_account_keyfile";
        parsedConfigFile.ethereum.ContractAddresses.KeepRandomBeacon = "";
        parsedConfigFile.ethereum.ContractAddresses.KeepGroup = "";
        parsedConfigFile.ethereum.ContractAddresses.Staking = "";
        fs.writeFile("/mnt/keep-client/config/keep-client-config.toml", tomlify.toToml(parsedConfigFile), (error) => {
          if (error) throw error;
        });
      }));
    }
  }
  catch(error) {
    console.error(error.message);
    throw error;
  }
};

/*
\heimdall aliens numbers.  Really though, the approveAndCall function expects numbers
in a particular format, this function facilitates that.
*/
function formatAmount(amount, decimals) {
  return '0x' + web3.utils.toBN(amount).mul(web3.utils.toBN(10).pow(web3.utils.toBN(decimals))).toString('hex');
};

provisionKeepClient().catch(error => console.error(error));

