
/*
We override transactionConfirmationBlocks and transactionBlockTimeout because they're
25 and 50 blocks respectively at default.  The result of this on small private testnets
is long wait times for scripts to execute.
*/
const web3_options = {
    defaultBlock: 'latest',
    defaultGas: 4712388,
    transactionBlockTimeout: 25,
    transactionConfirmationBlocks: 3,
    transactionPollingTimeout: 480
}
const Web3 = require('web3');
// ENV VARs sourced from InitContainer Dockerfile
const web3 = new Web3(new Web3.providers.HttpProvider(process.env.ETH_HOSTNAME + ':' + process.env.ETH_HOST_PORT), null, web3_options);
const fs = require('fs');
const toml = require('toml');
const tomlify = require('tomlify-j0.4');
const concat = require('concat-stream');

/*
Each <contract.json> file is sourced directly from the InitContainer.  Files are generated by
Truffle during contract and copied to the InitContainer image via Circle.
*/

// StakingProxy
const stakingProxyContractJsonFile = '/tmp/StakingProxy.json';
const stakingProxyContractParsed = JSON.parse(fs.readFileSync(stakingProxyContractJsonFile));
const stakingProxyContractAbi = stakingProxyContractParsed.abi;
// ENV VAR sourced from InitContainer Dockerfile
const stakingProxyContractAddress = stakingProxyContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const stakingProxyContract = new web3.eth.Contract(stakingProxyContractAbi, stakingProxyContractAddress);

// TokenStaking
const tokenStakingContractJsonFile = '/tmp/TokenStaking.json';
const tokenStakingContractParsed = JSON.parse(fs.readFileSync(tokenStakingContractJsonFile));
const tokenStakingContractAbi = tokenStakingContractParsed.abi;
const tokenStakingContractAddress = tokenStakingContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const tokenStakingContract = new web3.eth.Contract(tokenStakingContractAbi, tokenStakingContractAddress);

// KeepToken
const keepTokenContractJsonFile = '/tmp/KeepToken.json';
const keepTokenContractParsed = JSON.parse(fs.readFileSync(keepTokenContractJsonFile));
const keepTokenContractAbi = keepTokenContractParsed.abi;
const keepTokenContractAddress = keepTokenContractParsed.networks[process.env.ETH_NETWORK_ID].address;
const keepTokenContract = new web3.eth.Contract(keepTokenContractAbi, keepTokenContractAddress);

// keepRandomBeacon, only contract address for config file create
const keepRandomBeaconJsonFile = '/tmp/KeepRandomBeacon.json';
const keepRandomBeaconParsed = JSON.parse(fs.readFileSync(keepRandomBeaconJsonFile));
const keepRandomBeaconContractAddress = keepRandomBeaconParsed.networks[process.env.ETH_NETWORK_ID].address;

// KeepGroup, only contract address for config file create
const keepGroupJsonFile = '/tmp/KeepGroup.json';
const keepGroupParsed = JSON.parse(fs.readFileSync(keepGroupJsonFile));
const keepGroupContractAddress = keepGroupParsed.networks[process.env.ETH_NETWORK_ID].address;

// Stake a target eth account
async function provisionKeepClient() {

  try {
    // If it's a boostrap peer we assume existing account and use it accordingly.
    if (process.env.KEEP_CLIENT_TYPE === 'bootstrap') {
      console.log('<<<<<<<<<<<<  Provisioning keep-client Bootstrap Peer! '  + '>>>>>>>>>>>>')

      let bootstrapConfigFile = toml.parse(fs.readFileSync('/tmp/keep-client-bootstrap-peer-template.toml', 'utf8'));
      var operator = bootstrapConfigFile.ethereum.account.Address;

      console.log("Using pre-configured operator account " + operator)
      await unlockEthAccount(operator, process.env.KEEP_CLIENT_ETH_ACCOUNT_PASSWORD);

      console.log("Checking if bootstrap operator account is already staked")

    } else {
      console.log('<<<<<<<<<<<<  Provisioning keep-client Standard Peer! '  + '>>>>>>>>>>>>')
      console.log('Setup operator account:')

      let operatorEthAccountPassword = process.env.KEEP_CLIENT_ETH_ACCOUNT_PASSWORD;
      let operatorAccount = await createEthAccount('operator');
      var operator = operatorAccount['address'];

      await createEthAccountKeyfile(operatorAccount['privateKey'], operatorEthAccountPassword);

      // We wallet add to make the local account available to web3 functions in the script.
      await web3.eth.accounts.wallet.add(operatorAccount['privateKey']);

      console.log('Operator account provisioned!')
    }
    // Eth account that contracts are migrated against. ENV VAR sourced from InitContainer Docker image.
    let contractOwner = process.env.CONTRACT_OWNER_ETH_ACCOUNT_ADDRESS;

    console.log('<<<<<<<<<<<< Unlocking Contract Owner Account ' + contractOwner + ' >>>>>>>>>>>>');
    /*
    Transactions during staking are sent from contractOwner, must be unlocked before start.
    ENV VAR sourced from Kube config.
    */
    await unlockEthAccount(contractOwner, process.env.KEEP_CLIENT_ETH_ACCOUNT_PASSWORD);

    console.log('<<<<<<<<<<<< Staking Operator Account ' + operator + ' >>>>>>>>>>>>');
    await stakeEthAccount(operator, contractOwner);

    console.log('<<<<<<<<<<<< Creating keep-client Config File >>>>>>>>>>>>');
    await createKeepClientConfig(operator);

    console.log("keep-client provisioning complete!")
  }
  catch(error) {
    console.error(error.message);
    throw error;
  }
};

async function stakeEthAccount(operator, contractOwner) {

  // ENV VAR sourced from InitContainer Docker image.
  let magpie = process.env.CONTRACT_OWNER_ETH_ACCOUNT_ADDRESS;
  let contractOwnerSigned = await web3.eth.sign(web3.utils.soliditySha3(contractOwner), operator);

  /*
  This is really a bit stupid.  The return from web3.eth.sign is different depending on whether or not
  the signer is a local or remote ETH account.  We use web3.eth.sign to set contractOwnerSigned. Here
  the bootstrap peer account already exists and is hosted on an ETH node.
  ENV VAR sourced from kube config.
  */
  if (process.env.KEEP_CLIENT_TYPE === 'bootstrap') {
    var contractOwnerSignature = contractOwnerSigned;
  } else {
    var contractOwnerSignature = contractOwnerSigned.signature;
  }

  let signature = Buffer.from(contractOwnerSignature.substr(2), 'hex');
  let delegation = '0x' + Buffer.concat([Buffer.from(magpie.substr(2), 'hex'), signature]).toString('hex');

  console.log('Checking if stakingProxy/tokenStaking Contracts Are Authorized.');

  if (!await stakingProxyContract.methods.isAuthorized(tokenStakingContract.address).call({from: contractOwner}))
  {
    console.log('Authorizing stakingProxy/tokenStaking Contracts.')
    await stakingProxyContract.methods.authorizeContract(tokenStakingContract.address).send({from: contractOwner}).then((receipt) => {

    console.log(JSON.stringify(receipt));
    console.log('------------------------------')
    });
  }
  console.log('stakingProxy/tokenStaking Contracts Authorized!');
  console.log('Staking operator account ' + operator)

  await keepTokenContract.methods.approveAndCall(
    tokenStakingContract.address,
    formatAmount(1000000, 18),
    delegation).send({from: contractOwner}).then((receipt) => {
      console.log('Stake transaction receipt: \n' + JSON.stringify(receipt));
      console.log('------------------------------')
      console.log('Account ' + operator + ' staked!');
  });
};

async function createEthAccount(accountName) {

  let ethAccount = await web3.eth.accounts.create();

  // We write to a file for later passage to the keep-client container
  fs.writeFile('/mnt/keep-client/config/eth_account_address', ethAccount['address'], (error) => {
    if (error) throw error;
  });
  console.log(accountName + ' Account '  + ethAccount['address'] + ' Created!');
  return ethAccount
};

// We are creating a local account.  We must manually generate a keyfile for use by the keep-client
async function createEthAccountKeyfile(ethAccountPrivateKey, ethAccountPassword) {

  let ethAccountKeyfile = await web3.eth.accounts.encrypt(ethAccountPrivateKey, ethAccountPassword);

  // We write to a file for later passage to the keep-client container
  fs.writeFile('/mnt/keep-client/config/eth_account_keyfile', JSON.stringify(ethAccountKeyfile), (error) => {
    if (error) throw error;
  });
  console.log('Keyfile generated!');
};

async function unlockEthAccount(ethAccount, ethAccountPassword) {

  await web3.eth.personal.unlockAccount(ethAccount, ethAccountPassword, 150000);
  console.log('Account ' + ethAccount + ' unlocked!');
};

async function createKeepClientConfig(operator) {

  if (process.env.KEEP_CLIENT_TYPE === 'bootstrap' ) {
    fs.createReadStream('/tmp/keep-client-bootstrap-peer-template.toml', 'utf8').pipe(concat(function(data) {
      let parsedConfigFile = toml.parse(data);

      parsedConfigFile.ethereum.URL = process.env.ETH_HOSTNAME.replace('http://', 'ws://') + ':' + process.env.ETH_HOST_PORT;
      parsedConfigFile.ethereum.URLRPC = process.env.ETH_HOSTNAME + ':' + process.env.ETH_HOST_PORT;
      parsedConfigFile.ethereum.ContractAddresses.KeepRandomBeacon = keepRandomBeaconContractAddress;
      parsedConfigFile.ethereum.ContractAddresses.KeepGroup = keepGroupContractAddress;
      parsedConfigFile.ethereum.ContractAddresses.Staking = stakingProxyContractAddress;
      parsedConfigFile.LibP2P.Seed = '2';
      parsedConfigFile.LibP2P.Port = '3919';

      fs.writeFile('/mnt/keep-client/config/keep-client-config.toml', tomlify.toToml(parsedConfigFile), (error) => {
        if (error) throw error;
      });
    }));
  } else {
    fs.createReadStream('/tmp/keep-client-standard-peer-template.toml', 'utf8').pipe(concat(function(data) {
      let parsedConfigFile = toml.parse(data);

      parsedConfigFile.ethereum.URL = 'ws://' + process.env.ETH_HOSTNAME + ':' + process.env.ETH_HOST_PORT;
      parsedConfigFile.ethereum.URLRPC = process.env.ETH_HOSTNAME + ':' + process.env.ETH_HOST_PORT;
      parsedConfigFile.ethereum.account.Address = operator;
      parsedConfigFile.ethereum.account.KeyFile = '/tmp/eth_account_keyfile';
      parsedConfigFile.ethereum.ContractAddresses.KeepRandomBeacon = keepRandomBeaconContractAddress;
      parsedConfigFile.ethereum.ContractAddresses.KeepGroup = keepGroupContractAddress;
      parsedConfigFile.ethereum.ContractAddresses.Staking = stakingProxyContractAddress;

      fs.writeFile('/mnt/keep-client/config/keep-client-config.toml', tomlify.toToml(parsedConfigFile), (error) => {
        if (error) throw error;
      });
    }));
  }
  console.log("keep-client config written to /mnt/keep-client/config/keep-client-config.toml")
};

/*
\heimdall aliens numbers.  Really though, the approveAndCall function expects numbers
in a particular format, this function facilitates that.
*/
function formatAmount(amount, decimals) {
  return '0x' + web3.utils.toBN(amount).mul(web3.utils.toBN(10).pow(web3.utils.toBN(decimals))).toString('hex');
};

provisionKeepClient().catch(error => console.error(error));

