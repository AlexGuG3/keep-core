:toc: macro

= RFC 15: Slashing

:icons: font
:numbered:
toc::[]

== Background

To incentivize correct behavior in the Keep network,
misbehaving participants need to be punished.
In some situations,
another participant's cooperation is required to prove misbehavior.
This coordination is incentivized by rewarding the _tattletale_.

== Proposal

=== Goal

Slashing should be simple to implement and reason about.
The slashing method should implement the tattletale transfer mitigations
defined in the link:rfc-14-token-grants.adoc[token grant RFC],
always burning at least 95% of the penalty amount.

Only authorized operator contracts should be able to punish an operator,
but keeps created by keep factories
should not require individual authorization.

Some operator contracts may rely on an external trusted application
to determine whether misbehavior has occurred.
The impact of malfunctions in trusted applications should be minimized.

=== Implementation

Tokens are staked by transferring them to the staking contract.
The staking contract tracks the stake allocated to each _staker_.
Stakes can be _slashed_ to punish misbehavior.
Tokens backing slashed stakes are burned;
if a tattletale proves another operator's misbehavior
they will receive 5% of the slashed tokens,
the remainder being burned.

When an operator is punished for misbehavior,
they should be removed from the operation the misbehavior occurred in.

==== Authorization and slashing

_Operator contracts_ (including _keep factories_)
are authorized to impose penalties by stakers' _authorizers_.
All stakers using the same _authorizer_
share the set of authorized operator contracts.
Once given, this authorization cannot be revoked.

When a staker wishes to join an operation,
the contract responsible for initiating the operation
must be authorized by the staker's authorizer.
The operator contract checks its authorization status
when determining a staker's eligibility.

===== Directly authorized operator contracts

When an operator misbehaves on-chain,
the operator contract calls the staking contract to punish the operator.
The staking contract checks
that the operator contract is authorized to punish the staker,
and if true,
applies the penalty
by subtracting the applicable penalty from the operator's stake
and burns tokens equal to the penalty amount.

When a tattletale proves another operator's misbehavior,
the operator contract includes the tattletale operator's address in the call.
The staking contract subtracts the applicable penalty from the operator's stake
and burns 95% of it.
The remaining 5% is transferred to the tattletale's _beneficiary_ address.

===== Slashing by indirectly authorized keeps

_Keeps_ created by _keep factories_
are not individually authorized to impose punishments.
Instead, the _keep factories_ are authorized to impose punishments
and each keep factory tracks the individual keeps it has created.

When the keep wants to impose a punishment,
it includes its factory's address in the call to the staking contract.
The staking contract checks that the factory is authorized,
and the keep is listed as being created by the factory.

===== Trusted applications

Some operations rely on trusted input from a third-party application
to determine if misbehavior has happened.
These _trusted applications_ are authorized by the staker's authorizer,
separately from operator contracts.

When an operation involving such a trusted application is initiated,
the operator contract must include the trusted application's address
in the initiation event,
and check the trusted application's authorization 
alongside its own authorization status
when determining each staker's eligibility to join.

Trusted applications cannot punish stakers directly;
they must go through the responsible operator contract.
When the trusted application claims misbehavior has occurred,
the operator contract applies the punishment normally.

==== Penalty amounts

Penalties for misbehavior could be adjusted
to match the severity of the misbehavior.
However, initially a simple rule should be sufficient:
when `op_contract` imposes a punishment,
the amount slashed should equal
the minimum stake required to participate in operations on `op_contract`.
If contract _Foo_ requires 10,000 KEEP to participate with one virtual staker,
_Foo_ should slash a misbehaving virtual staker by 10,000 KEEP.

==== Interface requirements

===== Staking contract: slashing

`slash(address perp, tokens sum)`::

Check that `msg.sender` is authorized to slash `perp`:
`isAuthorized(msg.sender, perp.authorizer) == true`.
+
Take `sum` tokens from stake of `perp` and burn them.

`seize(address perp, tokens sum, address mole)`::

Check that `msg.sender` is authorized to slash `perp`:
`isAuthorized(msg.sender, perp.authorizer) == true`.
+
Take `sum` tokens from stake of `perp`;
burn `sum * 0.95`; transfer `sum * 0.05` to beneficiary of staker `mole`.

`indirectSlash(address factory, address perp, tokens sum)`::

Check that `factory` is authorized to slash `perp`:
`isAuthorized(factory, perp.authorizer) == true`.

Check that `factory` lists `msg.sender` among keeps it created
`factory.made(msg.sender) == true`.

Take `sum` tokens from stake of `perp` and burn them.

`indirectSeize(address factory, address perp, tokens sum, address mole)`::

Check that `factory` is authorized to slash `perp`:
`isAuthorized(factory, perp.authorizer) == true`.
+
Check that `factory` lists `msg.sender` among keeps it created:
`factory.made(msg.sender) == true`.
+
Take `sum` tokens from stake of `perp`;
burn `sum * 0.95`; transfer `sum * 0.05` to beneficiary of staker `mole`.

===== Staking contract: authorizations

`authorize(address op_contract)`::

Authorize `op_contract`.
Operators using `msg.sender` as their authorizer
may now join operations on `op_contract`
and `op_contract` may slash their stakes.

`isAuthorized(address op_contract, address by) -> bool`::

Check if the authorizer `by` has authorized `op_contract`.

`trust(address app)`::

Authorize `app` as a _trusted application_.

`isTrusted(address app, address by) -> bool`::

Check if authorizer `by` has authorized `app` as a trusted application.

===== Token contract

`burn(amount sum)`::

Any address that holds tokens can call `burn(amount sum)`
to burn `sum` tokens, limited by tokens held by the address.

===== Keep factory

Keep factories should maintain a list of keeps they have created.

`made(address keep) -> bool`::

Return whether `keep` was created by this factory.

=== Limitations

Slashing is not limited to the amount originally staked
for participating in the relevant operations;
a malfunctioning operator contract could cause a staker to lose all stake.

When an operator contract relies on a trusted application,
it is imperative for the operator contract to verify
that the stake a trusted application tries to slash
corresponds to an operation that the staker participates in
and has not yet been slashed for.

== Future Work

With a different staking paradigm that tracks individual operations,
it is possible to limit the risk
from malfunctioning operator contracts or trusted applications
to the stake actually corresponding to the operations.

[bibliography]
== Related Links

- link:rfc-14-token-grants.adoc[RFC 14: Token grants]
