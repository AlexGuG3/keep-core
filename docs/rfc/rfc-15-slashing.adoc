:toc: macro

= RFC 15: Slashing

:icons: font
:numbered:
toc::[]

== Background

To incentivize correct behavior in the Keep network,
misbehaving participants need to be punished.
In some situations,
proving misbehavior requires cooperation from another participant,
a _tattletale_.
This coordination is incentivized by rewarding the _tattletale_
by granting them a fraction of the tokens
taken from the misbehaving participant.

== Proposal

=== Goal

Slashing should be simple to implement and reason about.
The slashing method should implement the tattletale transfer mitigations
defined in the link:rfc-14-token-grants.adoc[token grant RFC],
always burning at least 95% of the penalty amount.

To protect staker funds,
only authorized operator contracts should be able to punish an operator.

=== Implementation

Tokens are staked by transferring them to the staking contract.
The staking contract tracks the stake allocated to each _staker_.
Stakes can be _slashed_ to punish misbehavior.
Tokens backing slashed stakes are burned;
if a tattletale proves another operator's misbehavior
they will receive 5% of the slashed tokens,
the remainder being burned.

When an operator is punished for misbehavior,
they should generally be removed
from the group/keep the misbehavior occurred in.

==== Authorization

_Operator contracts_ are authorized to impose penalties
by stakers' _authorizers_.
All stakers using the same _authorizer_
share the set of authorized operator contracts.
Once given, this authorization cannot be revoked by the authorizer.

When a staker wishes to join a group
the contract responsible for creating the group
must be authorized by the staker's authorizer.
The operator contract must check its authorization status
when determining a staker's eligibility.

In the random beacon a staker's eligibility is checked
when tickets are submitted;
this means that authorization must be checked
when validating a ticket.
If an operator submits a ticket to an unauthorized operator contract,
the ticket must be rejected as invalid.

==== Penalties

When an operator misbehaves on-chain,
the operator contract calls the staking contract to punish the operator.
The staking contract checks
that the operator contract is authorized to punish the staker,
and if true, applies the penalty.

===== Pure slashing

When misbehavior is detected without third-party input,
a _pure slashing_ penalty is applied.
Pure slashing means that the staking contract
subtracts the applicable penalty from the operator's stake
and burns tokens equal to the penalty amount.

An example of a pure slashing penalty would be
when a beacon group fails to produce a signature within the deadline.
In this case all members of the group are punished,
and nobody is rewarded.

===== Seizing

When a tattletale proves another operator's misbehavior,
a fraction of the penalty amount is _seized_ and transferred to the tattletale,
while the rest is burned.

To apply a seizing penalty,
the operator contract includes the tattletale operator's address in the call.
The staking contract subtracts the applicable penalty from the operator's stake
and burns 95% of it.
The remaining 5% is transferred to the tattletale's _beneficiary_ address.

===== Penalty amounts

Penalties for misbehavior could be adjusted
to match the severity of the misbehavior.
However, initially a simple rule should be sufficient:
when `op_contract` imposes a punishment,
the amount slashed should equal
the minimum stake required to participate in operations on `op_contract`.
If contract _Foo_ requires 10,000 KEEP to participate with one virtual staker,
_Foo_ should slash a misbehaving virtual staker by 10,000 KEEP.

==== Interface requirements

===== Staking contract: slashing

`slash(address perp, tokens sum)`::

Check that `msg.sender` is authorized to slash `perp`:
`isAuthorized(msg.sender, perp.authorizer) == true`.
+
Take `sum` tokens from stake of `perp` and burn them.

`seize(address perp, tokens sum, address mole)`::

Check that `msg.sender` is authorized to slash `perp`:
`isAuthorized(msg.sender, perp.authorizer) == true`.
+
Take `sum` tokens from stake of `perp`;
burn `sum * 0.95`; transfer `sum * 0.05` to beneficiary of staker `mole`.

===== Staking contract: authorizations

`authorize(address op_contract)`::

Authorize `op_contract`.
Operators using `msg.sender` as their authorizer
may now join operations on `op_contract`
and `op_contract` may slash their stakes.

`isAuthorized(address op_contract, address by) -> bool`::

Check if the authorizer `by` has authorized `op_contract`.

===== Token contract

`burn(amount sum)`::

Any address that holds tokens can call `burn(amount sum)`
to burn `sum` tokens, limited by tokens held by the address.

=== Misbehavior and penalties in the Random Beacon

==== DKG

===== Invalid ticket

An operator might submit an invalid ticket in the DKG.

Invalid tickets are detected automatically
without the need for a tattletale.

Proof of invalid tickets is _objective_,
as all information required to verify tickets is available on-chain.

Because the cost of ticket submission is paid by the submitter,
the ticket can be simply rejected and the transaction reverted.

===== Failure to produce a DKG result

The created group might fail to produce a valid result.

Failure to finish DKG is detected automatically.

Failure to finish DKG is _objective_.

Failure to produce a result means
that a honest and available majority
was not present in the DKG for some reason or other.
The precise reasons can be unpredictable.
Failing to finish DKG is inherently punished
by the opportunity cost of not getting into a signing group
despite having paid the ticket submission fees.
Because of this,
failure to produce a valid DKG result should not be separately penalized
without further examination of the possible causes of failure
and the effects of collective punishment.

===== Submitting an invalid DKG result

An operator might submit an invalid result for the DKG.

Invalid DKG results are detected automatically.

Proof of invalid DKG results is _objective_.

Because the cost of verifying a DKG result is paid by the submitter,
and the submitter is reimbursed only for valid results,
submitting invalid results inherently punishes itself
and no further penalty is needed beyond reverting the transaction.

===== Inactivity in DKG

An operator might fail to send a required message during DKG.
This lowers the effective safety margin of the group
against lynchpinning and inability to produce a signature.

Inactivity in DKG is determined by
the list of inactive members in the DKG result submission.

Unless DKG is performed on-chain,
proof of inactivity in DKG is _subjective_
and subject to the honest majority assumption;
a dishonest majority could always forge a false proof of inactivity.
It is not possible to make off-chain DKG inactivity objectively provable.

Inactive members shall be removed from the group,
but not otherwise punished;
the opportunity cost of not being included in the group
already provides an incentive to be active.

===== Disqualification in DKG

An operator might misbehave in a variety of ways during DKG.
Active misbehavior can lower the effective safety margin of the group
against frontrunning, lynchpinning, or signature failure.

Disqualification in DKG is determined like inactivity,
by the list of disqualified members being included in the result submission.

On-chain proof of disqualification is _subjective_
and a dishonest majority could forge a false proof.

Punishing disqualified members based on subjective proof
creates opportunities for dishonest majorities
to attack other stakers
in a way which extends beyond the damage caused by frontrunning the beacon.
Because of this,
punishing disqualified members without objective proof
requires further examination of the associated risks and incentives.

However, misbehavior is defined by there being _objective_ off-chain proof,
so the operator contract could be made to verify DKG transcripts
to render DKG disqualification _objective_ on-chain as well.

Disqualified members must be removed from the group.
If disqualification is objectively proven,
the operator must be punished with _seizing_ their stake.
The submitter of the transaction containing the DKG transcript
shall be the _tattletale_.

==== Signing

===== Invalid signature share

===== Submitting an invalid signature

===== Unauthorized use of keyshare

===== Creating an unauthorized signature

=== Limitations

Slashing is not limited to the amount originally staked
for participating in the relevant operations;
a malfunctioning operator contract could cause a staker to lose all stake.

Chain reorganizations may lead to honest behavior in one fork
being punishable misbehavior in another.
Mitigations for this have not been included in this RFC.

== Future Work

With a different staking paradigm
that tracks individual keep and group memberships,
it is possible to limit the risk
from malfunctioning operator contracts or trusted applications
to the stake actually corresponding to the operations.

This RFC doesn't cover authorizing individual keeps,
or situations where a trusted application
has the authority to impose a penalty.

Because authorizations cannot be revoked,
operator contracts can safely cache positive authorization
after the first lookup to the staking contract.
Lack of authorization cannot be cached,
as the operator contract could later become authorized.

Punishing the failure to produce a DKG result
has interesting implications that could be explored further.

Punishing disqualified DKG members on subjective proof
creates opportunities to attack honest stakers
but can also provide a way for compromised groups
to profitably reveal and remove themselves
if seizing on subjective proof is permitted.
The implications and tradeoffs of
concentrated vs. distributed risk are interesting.

[bibliography]
== Related Links

- link:rfc-14-token-grants.adoc[RFC 14: Token grants]
