:toc: macro

= RFC 2: Network Security Implementation

:icons: font
:numbered:
toc::[]


== Proposal
In this document, we describe the implementation details of the Keep network 
security mechanisms meeting requirements specified in 
link:rfc-1-network-security-requirements.adoc[RFC 1]

=== Goal

Messages exchanged in the network must be attributable, maintain integrity,
and must optionally be confidential.

=== Implementation

==== Network topology and application-level messaging

It is important to understand the difference between the network topology 
and communication between peers on the application level. Peers connect to 
each other based on the rules defined by the underlying P2P network protocol. 
Two peers exchanging messages on the application level do not necessarily 
need to have a direct connection with each other on the network level. It is 
possible that messages exchanged at the application level by two peers are 
relayed by other peers on the network level.

On the network level, we require all peers to prove their identity and minimum 
stake when they establish a connection with each other. All peers monitor the 
on-chain stake of peers they are connected to and are obligated to drop the 
connection with the given peer if that peer's on-chain stake drops below the 
required minimum. This requirement enforces that only peers with a minimum 
stake are able to be a part of the network and this requirement is enforced by 
all peers individually.

Attributability, integrity and optional confidentiality of messages are 
requirements enforced on the application level. Even if a message between two 
peers was relayed by others, this message still needs to fulfil all of those 
requirements. Since two peers exchanging messages do not necessarily need to 
have a connection on the network level with each other, they also perform an 
identity and stake check before the communication between them happens.

==== Peer identification
Each peer is identified by a static public key equal to the delegate key 
associated with an on-chain stake. No two peers in the network are permitted 
to have the same static public key

==== Network join protocol

Keep publishes a list of recommended bootstrap peers but every other network 
member can enable the bootstrap capability as well. The list contains addresses of 
bootstrap peers and their static public keys. Bootstrap peers are just like any 
other peers, but with the added capability of being able to handle network join 
requests.

The result of joining the network is inherently dependent on the bootstrap peer's 
announced view of the network, that is why choosing a right bootstrap peer is so 
important. Using a malicious bootstrap peer may lead to joining a fake network if 
the malicious bootstrap peer and other fake network members can prove the ownership 
of their on-chain stakes. Using a recommended but hacked bootstrap peer may lead to 
not establishing connections with any other peers in the network if the hacked 
bootstrap peer does not properly announce new peer's presence.

A peer wanting to connect to the network sends a network join request to one of 
the bootstrap peers. Each peer wanting to join a network needs to provide a proof
of ownership of an on-chain identity with an associated stake. As part of the 
network join handshake, the bootstrap peer will also provide proof of its own stake.

The procedure is as follows:

1. Peer joining the network initiates the protocol by sending a network join 
   request message containing randomly generated nonce `n_1`, an 8-byte (64-bit) 
   unsigned integer, to the bootstrap peer. The message is signed with the 
   peer's static private key.
2. The bootstrap peer randomly generates nonce `n_2`, which is also an 8-byte unsigned 
   integer, and computes a `challenge` which is the result of calling a cryptographic hash 
   function `hash` on the concatenated bytes of `n1` and `n2` (referenced as `n1 || n2`). 
   The bootstrap peer sends back `challenge,` `n_2` and signs the message with its static 
   private key.
3. The peer joining the network recomputes the challenge from `n_1` and `n_2`; if it 
   matches the challenge sent by the bootstrap peer, it answers with a message 
   containing the challenge. The message is signed with the peer's static private key.
4. The bootstrap peer validates the challenge.

```
JOINING PEER                                      BOOTSTRAP PEER

n_1 = random_nonce()
Message { n_1 } ---->
                                                  n_2 = random_nonce()
                                                  challenge = hash(n_1 || n_2)                                  
                                                  <---- Message { challenge, n_2 }
challenge = hash(n_1 || n_2)
Message {challenge} ---->
```

Message signature is checked for any message that is received. Any message with
an invalid signature immediately aborts the protocol. If all signatures have been 
valid and challenge response was as expected, both parties execute a check for an 
on-chain stake of each other. If the peer joining the network has a minimum stake,  
the bootstrap peer connects the peer to the network and announces peer's presence. 
If the bootstrap peer has a minimum stake, peer joining the network 
decides to connect to the bootstrap peer and becomes a part of the network.
Nonces and challenge generated during the handshake are discarded. 
Otherwise, when at least one of the parties does not have a minimum stake, the 
protocol is aborted. If the bootstrap peer had a deficient stake, the peer joining
the network executes the protocol again with the next bootstrap peer.

==== Network peer authorization protocol

Once a peer has completed the network join protocol successfully, it is connected to 
a bootstrap peer and is a full-fledged network member. It starts discovering other 
peers in the network and connects to some of those according to the peer discovery
strategy implemented in the network. Before the peer decides to connect to any other 
network member, the same nonce, challenge, and stake check protocol must be executed
between the peer and the new network member it is connecting to. 
Peers decide to connect to each other only if they both complete the 
protocol successfully and prove their on-chain minimum stakes. This is a trust no-one 
strategy which allows for even a corrupted network to heal in the case of a malicious 
split brain event.

==== Attributability and integrity of messages

All messages in the network are signed with sender's private static key. Before 
any two peers start exchanging messages, they need to agree on a common nonce 
(8-byte unsigned integer) that will be used to track the order of messages as well 
as to prevent replay and message-from-future attacks. The protocol is similar 
to the one used to create a challenge:

```
PEER 1                                          PEER 2

n_1 = random_nonce() 
Message { n_1 } ---->
                                                n_2 = random_nonce()
                                                nonce = hash(n_1 || n_2).toInt
                                                <---- Message { n_2 }
nonce = hash(n_1 || n_2).toInt
```

Once peers agree on a common initial nonce they both execute a check for an 
on-chain stake of the second party. If at least one of the peers does not have a 
minimum stake, protocol is aborted and all messages from that peer are rejected.

Sender's nonce is tracked per individual peer. Each message sent from a peer 
must have a nonce greater by one from the nonce of the previous message. The 
nonce is included in a message in a way that makes it a part of the content used 
to produce a signature. Nonce expires if two peers do not communicate for a 
certain period of time. Nonce timeout is a parameter tracked on-chain. Two peers 
need to execute the handshake protocol again to initialize a new nonce if the 
previous one has expired. If the nonce has exhausted (reached the maximum
possible value), it should be set back to 0.

All messages received from a given peer must contain nonces forming an ordered 
sequence. If a peer receives a message with nonce less than or equal to the most 
recent one for the given sender, the message is rejected and the sender is 
informed about that. Due to the nature of the network, some messages can be lost 
or delayed. Each peer has a cache of messages sent and received within a fixed 
time window. If a received message has a nonce greater by more than one from the 
currently expected nonce, that message is added to cache but it’s not accepted
until the gap between the expected and message’s nonce is filled. There is a 
fixed, short time limit under which the gap must be filled. If that does not happen, 
the message is rejected and the sender is informed about this fact. Message 
rejected notification contains a nonce of a message that was rejected as well as 
the currently expected nonce. Sender, having the cache of messages sent in the 
fixed time window resends all the messages starting from the one with nonce 
expected by the receiver. If sender does not provide the missing messages 
within a fixed timeout, receiver drops the connection.

Sent and received messages cache window, time after a notification about 
rejecting a message is sent as well as time after connection is droped if 
expected messages were not delivered should be the same for all peers in the 
network. These values are fixed and tracked on-chain as system constants which
require a hard-fork-level event to change. 

All peers in the network have a streaming view of the latest chain state that 
notifies in an event-style when a given address falls below the minimum stake.

If stake drops down below the required minimum for some peer, that peer's nonce 
is discarded and all connections to that peer are dropped and any unprocessed 
messages from that peer are immediately discarded. Once the peer increases 
its stake so that it is above the required minimum, it must initialize its 
connections with any disconnected peers once again in order to be able to 
communicate with them.

When peer receives a message it firsts check the signature. If it matches, then 
peer validates the nonce. If the nonce is greater by one from the nonce included 
in the previous message, then the message is accepted.

==== Message Confidentiality

Encryption is based on ephemeral keys generated individually for each protocol 
execution. Only point-to-point communication can be encrypted. 

Before the encrypted communication can happen, both involved peers generate a 
symmetric key using 
link:http://noiseprotocol.org/noise.html#interactive-handshake-patterns-fundamental[`Noise_XK`] 
protocol. 

Any of the communicating peers can reveal the symmetric key in order to publicly 
publish a complaint about the other peer's message. In such case, the symmetric 
key is considered as compromised and should not be used for further 
communications.

==== Message relay

Two peers communicating on the application level do not necessarily need to 
have a direct network-level connection with each other. It is possible messages 
are relayed by other peers. Each peer relaying the message validates the message 
signature against sender's key. If the signature is not valid, peer rejects the 
message and drops the connection with the peer that relayed that message since that 
peer is the one that tampered the message.

==== Group formation

In the Keep network, peers may form groups selected to execute various protocols.
The output of the group formation protocol is a list of on-chain addresses. When 
peer joins a group, it broadcasts its public static key which is used by other 
peers in the group to derive the on-chain address of that peer. All the peers in 
the group must execute the handshake protocol described in the 
<<Attributability and integrity of the network messages>> section. If two peers 
executed that protocol before (even as a members of some other group), they  
still use the same nonce and don't have to execute the protocol again. 

[bibliography]
== Related Links

- Discussions on writing this document:
https://www.flowdock.com/app/cardforcoin/tech/threads/Zc_bHNDU5eNJY8JHB22NfU2a9Bk

- Noise Protocol documentation: http://noiseprotocol.org/noise.html

- Noise Protocol variations matrix:
https://latacora.singles/2018/07/18/factoring-the-noise.html

- Lighting Network Noise implementation:
https://github.com/lightningnetwork/lnd/tree/master/brontide
