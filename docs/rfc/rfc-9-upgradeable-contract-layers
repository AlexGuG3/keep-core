:toc: macro

= RFC 9: Upgradeable layers in contracts

:icons: font
:numbered:
toc::[]

== Background

Securely upgradeable work contracts
are important for protecting stakers' tokens.
However, deploying a new contract on every upgrade,
which stakers will then individually authorize,
makes migrating between implementations difficult.
Common ways of upgrading contracts,
such as the "eternal storage" pattern,
are incompatible with individual upgrade authorization.

=== Current Functionality

The current design for upgrading work contracts
is to deploy a new version on every upgrade,
and wait for stakers to start operating on it.
Older versions would by necessity keep existing
in parallel with newer ones,
and migrating state between versions
is difficult if not impossible.
It is possible that the difficulty of migration
would lead customers to prefer the old version with established state.

== Proposal

The eternal storage pattern can be implemented
on individually authorizable work contracts
by dividing the contracts into a security-critical back-end
and a front-end which provides services to customers.
A single front-end contract
can abstract over multiple different back-end contracts,
permitting secure upgrades with reduced or minimal disruption to customers.

=== Goal

The goal of this proposal. What are we trying to achieve? Examples of desired
outcomes would be handy.

=== Implementation

For each service provided on the Keep network,
the security-critical components are identified
and separated from the rest of the contract
as a _back-end_ contract.
The _front-end_ contract
can abstract over multiple different versions of the back-end,
presenting a unified interface to customers.
Behind that interface,
security-critical elements are delegated to back-end contracts.

==== Back-end

The back-end contracts handle all operations
that may have an impact on staked tokens.

Each back-end contract is an independent "microservice",
keeping its own state on security-critical data.
The backend contracts provide simplified functionality
that is stripped to the minimum necessary
for security and correct incentives.

Each backend contract is associated with one or more front-end contracts
the backend contract provides functionality for.
Only these specified frontend contracts
may use the backend contract's interface.
When the interface is designed,
the frontend contract must be treated as untrusted
and the backend must maintain correctness
regardless of the frontend input.

When a backend contract performs a service,
it is paid for the service provided.
The payment is distributed according to the backend's own rules.

==== Front-end

Front-end contracts use the basic functionality
performed by backend contracts,
to provide useful services to customers.

Front-end contracts receive requests for services from customers,
and divide the provided service to backend and frontend components.
Elements that are critical for security and incentives
are delegated to a backend contract,
while other parts of the work are performed in the frontend.

Frontend contracts can use
multiple different versions of back-end contracts
to perform the backend functions.
The frontend keeps shared state which is not security-critical.

==== Back-end upgrades

A backend contract is upgraded by deploying a new version,
and adding it to the available backends of a frontend contract.
As stakers authorize the new backend,
the frontend can gradually migrate
to use the new backend over older versions.

Backend contracts can be upgraded
without losing frontend contract state,
but critical state is held within the backend contract
and cannot be migrated.

==== Front-end upgrades

Because backend contracts are designed
to be independent of frontend contract security and correctness,
there is much more leeway to upgrade frontends.

Frontend contracts can be directly upgradeable,
e.g. with the eternal storage pattern;
they may be immutable,
only accepting new backend versions;
or they may implement a similar pattern
in the direction of customers,
unifying core functionality
between immutable public interface contracts.

Because backend contracts can serve multiple frontends,
immutable frontend contracts can be upgraded
by deploying the new frontend version,
along with a new backend version
which can serve both the new and the old frontend.
The old frontend can migrate work onto the new backend,
remaining perfectly functional while the new frontend is spun up.

==== Staking contract upgrades

TBD

=== Limitations

Untrusted frontend contracts mean
that security-critical state must be kept in the backend.
If the network service has complex security needs,
the backend may have to implement most of the work logic.

Security-critical state cannot be migrated between backends;
a new 

=== Example

TBD

== Future Work (optional)

If applicable, what future evolutions could you see this approach leading to?
Particularly if these possibilities influenced your thinking about the main
proposal, this is important.

== Open Questions (optional)

If any open questions are left that you haven't yet investigated, what are they?

[bibliography]
== Related Links

- Flowdock Links
- Other links
- If you have publications, you can include them in bibliography style. If you
  start your bullet with an id in _triple_ square brackets (e.g. `+[[[AAKE]]]+`),
  you can reference it in the content body using regular cross-reference syntax
  (e.g. `+<<AAKE>>+`).
