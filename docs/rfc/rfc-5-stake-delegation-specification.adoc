:toc: macro

= RFC: Stake delegation specification

:icons: font
:numbered:
toc::[]

== Background

Keep tokens are going to be staked by having token owners delegate their staked
balance to an operator account and use it to run the Keep Client. The operator
account cannot access the stake directly, nonetheless, it operates on behalf of
the owner and bad acting will result in slashing the owners' stake. The operator
may be a third party, or it may be a different address controlled by the owner.

Stake delegation will be beneficial for the security of Keep users as it allows
for on-stake operations with a "cold wallet". Thus, putting Keep users wallets
offline protects them from "hacks" and stake delegation enables continuous
rewarding on safe operations on staked assets. Also exposure of Keep users
public keys will be limited. 

=== Terminology

owner:: The address of an owner of the staked tokens.

operator:: The address of a party authorized to operate a stake on behalf of a
  given _owner_.

magpie:: The address where the rewards for participation are sent, earned by an
  _operator_, on behalf of an _owner_.

delegated stake:: An _owner_'s staked tokens, delegated to the _operator_ by the
  _owner_.

on-stake:: Refers to the type of operations performed by an _operator_ on a
  _delegated stake_.

== Proposal

Stake delegation enables a token _owner_ to delegate their already-staked tokens
to an _operator_ and enables an _operator_ to operate staked tokens on behalf
of the _owner_. The owner also defines a _magpie_ address (recipient) where all
rewards generated by the _operator_ for the staked tokens are sent.

=== Goal

The goal of this proposal is to specify a simple and secure stake delegation
mechanism. It should enable Keep users to have their wallets offline and their
stake operated by operators on their behalf. The Keep client software should
be able to run without exposing Keep operator's private key and should not
require any owner's keys at all. The stake delegation should also optimize
the network throughput without compromising the security of owners stake.

=== Design Assumptions

1. _owner_ can only have one operator.
2. _owner_ can only delegate all of his stake.
3. _operator_ cannot have any stake of his own.
4. _operator_ cannot have any tokens at all.
5. _operator_ can only have a _delegated stake_ from only one _owner_.
6. If an _owner_ tries to delegate to more than one operator, the tx must
fail.
7. If an _owner_ tries to delegate a stake to an _operator_ who already has a
stake, the tx must fail.
8. The end of an _on stake operation_ happens only after all rewards are
granted and all penalties are imposed. 
9. Rewarding and penalization happens as the last phase of all operations.

== Roles

In this proposal, we are specifying three roles, owner, operator, and magpie.
They are briefly characterized in this section.

=== Owner

The owner is the ultimate holder of the tokens. Before staking, the owner has
full control over the tokens, and the tokens are returned to the owner after
staking has finished. The owner's participation is not required in the
day-to-day operations of the staker, so cold storage can be accommodated to the
maximum extent.

The owner address is used to initiate staking and create the staker, and to
finish staking and reclaim the staked tokens.

=== Operator

The operator handles the everyday operations of the staker without actually
owning the staked tokens. While this enables third-party delegation without eg.
making it possible for the operator to simply transfer away tokens, it should be
noted that a malicious operator can exploit stake slashing to steal or destroy
tokens and thus the entire staked amount is indeed at stake.

The operator address is used to provide network functionality by participating
in various protocols. A signature from the operator is also required to initiate
staking, and the operator can unilaterally finish staking and return the tokens
to the owner.

=== Magpie

The magpie collects rewards earned from staking and participating in the
network. The magpie doesn't sign or publish any protocol-relevant transactions,
but any currency or tokens earned by the staker will be transferred to the
magpie.

== Specification Architecture

Accordingly to the design strategy and design requirements the design
architecture should be based on the following combinations of strategies:

(optional Atomic) Multi-Operating with Dynamic or Static MINIMUM_STAKE and
Delayed Undelegation with Misbehaving or Consequent Penalisation

Other strategies tend to be suboptimal from the perspective of both security and
network throughput requirements.

From the engineering perspective, the solution that is selected and specified in
this document is: _(optional Atomic) Multi-Operating with Static MINIMUM_STAKE
and Delayed Undelegation with Consequent Penalisation_. The main motivation
behind choosing these particular strategies is its simplicity and minimization
of the number of necessary changes to the current implementation and shorten the
time to deliver a workable solution.

=== Atomic Multi-Operating with Static MINIMUM_STAKE and Delayed Undelegation with Consequent Penalisation

In this section, we are going into the details of the main proposal. First, we
are going to briefly describe specific features of the solution and then we will
focus on implementation and functional details.

==== Features characterization
The features of the proposed solution are briefly described in this section. For
more in detail characterization and discussion please refer to the Stake
Delegation Requirements RFC document.

===== (optional) Atomic Operating
Atomic Operating is an optional feature, that limits the number of possible
operations, which can be executed by an operator. It enables monitoring and
limiting the stake usage/burning process, therefore it also decreases the
network throughput.

===== Multi-Operating
Multi-Operating feature enables a virtually unlimited number of operations
on a delegated stake. It allows operators to operate on a delegated stake
without any limits (except the MINIMUM_STAKE requirements).

===== Static MINIMUM_STAKE
Static MINIMUM_STAKE feature determines that the value of the MINIMUM_STAKE will
be constant through the network lifetime. It can only be changed during a
hard-fork.

===== Delayed Undelegation
Delayed Undelegation defines a mechanism for revoking a delegation. The
undelegation happens during an undelegation period when an operator has time to
end all of the ongoing operations. During the undelegation period, the delegated
stake is locked and no additional operations are allowed, except those already
started. After an undelegation period timeout, the delegated stake is released
to the owner and a bound between operator, stake, and the owner is removed.

===== Consequent Penalization
Consequent Penalization refers to the way to penalize undelegation. When an
undelegation happens during an operation and operations terminates successfully,
then there is no penalty. If the operation terminates unsuccessfully, then the
penalties are imposed.

== Specification

=== Contract structure

==== Delegating contrat
* _delegating contract_
  ** _tokens[owner] -> amount_ table
  ** _staking[owner] -> delegation_id_ table
  ** _operating[operator] -> delegation_id_ table
  ** _op_agreement[delegation_id] -> agreement_ table with:
    *** _amount_ of staked tokens
    *** (if atomic alternative is desired:)
      **** _free_tokens_ unallocated to any contract
      **** _locked_tokens[contract_address] -> amount_ table of allocated tokens
    *** _state_ of the staking agreement
    *** _since_ last change
    *** _owner_ of the tokens
    *** _operator_ performing actions
    *** _magpie_ receiving rewards
  ** `delegate` method for delegating
  ** `undelegate` method for initiating undelegation
  ** `reclaim` method for finishing undelegation and freeing tokens
  ** `penalize` method for slashing stakes and rewarding tattletales with tokens
  ** `reward` method for paying out currency rewards
  ** (if atomic alternative is desired: `lock` method for assigning tokens to
  contracts and `unlock` to free the tokens)

=== Functionality

==== Delegating a stake

1. The _owner_ chooses the _staked amount_, and the _operator_, _magpie_ and
creates a _delegation order_ containing this information.

2. Both the _owner_ and _operator_ sign the _delegation order_.

3. The _delegation order_ is published on-chain.

4. The contract receives the _delegation order_ and verifies the following (if
any condition is unfulfilled, processing aborts):
  * _delegation order_ is signed by the owner declared in the delegation order
  * _delegation order_ is signed by the operator declared in the delegation order
  * `magpie == nil`
  * `staking[owner] == nil`
  * `operating[operator] == nil`
  * `tokens[owner] >= staked_amount >= minimum_stake`

5. If all conditions are satisfied the contract processes the _delegation order_
and sets the following:
  * `staking_time := current_time`
  * `delegation_id := hash(owner, operator)`
  * `tokens[owner] -= staked_amount`
  * `staking[owner] := delegation_id`
  * `operating[operator] := delegation_id`
  *  {blank}
+
....
op_agreement[delegation_id] := {
  amount = staked_amount,
  (for atomic alternative) free_tokens = staked_amount,
  state = Active,
  since = staking_time,
  owner = owner,
  operator = operator,
  magpie = magpie
}
....

6. The _operator_ can now use delegated stake for operating.

==== An N-to-N variant note
A _n-to-n_ variant can be designed where owners and operators are not tied to a
single delegation, but an owner can delegate to unlimited operators, an operator
can operate for unlimited owners, and each _owner, operator_ pair can have
unlimited delegation agreements between each other.

This would be done by eliminating the `staking[owner]` and `operating[operator]`
tables, and by setting `delegation_id := hash(owner, operator, staking_time)`.
With this change, the only limit is that the owner and operator can only
establish a single delegation agreement in a single block.


=== Undelegating a stake

1. The _owner_ or _operator_ chooses to unstake, and creates a
_undelegation order_ containing the _delegation ID_.

2. Either the _owner_ or _operator_ signs the _undelegation order_ and publishes
it on-chain.

3. The contract receives the _undelegation order_ and verifies the following
(`d_agreement := op_agreements[delegation_id]`):
  * `d_agreement != nil`
  * The _undelegation order_ is signed by either `d_agreement.owner` or
  `d_agreement.operator`

4. If the conditions are satisfied, the contract processes the
_undelegation order_ and sets the following:
  * `unstaking_time := current_time`
  * `d_agreement.state := Unstaking`
  * `d_agreement.since := unstaking_time`
  * (for atomic alternative) `unlock` the `locked_tokens` associated with this
  _delegation ID_

5. The _operator_ can not enter new operations until the undelegated stake is
reclaimed and the _owner_ can not delegate to new a _operator_.

=== Claiming undelegated stake

1. After `unstake_delay` has passed since the _undelegation order_ has been
processed, the _owner_ or _operator_ creates, signs and publishes a
_stake reclaiming order_ containing the _delegation ID_.

2. The contract receives the _stake reclaiming order_ and verifies the
following (`d_agreement := op_agreements[delegation_id]`):
  * `d_agreement != nil`
  * The _stake reclaiming order_ is signed by either `d_agreement.owner` or
  `d_agreement.operator`
  * `d_agreement.state == Unstaking`
  * `d_agreement.since + unstake_delay =< current_time`

3. The contract processes the _stake reclaiming order_ and sets the following:
  * `tokens_undelegated := d_agreement.amount - undelegation_penalties` 
  (`undelegation_penalties` applies if eg. an operation is still underway and 
  it has been decided to set penalties for reclaiming stakes in such a situation)
  * `staking[owner] := nil`
  * `operating[operator] := nil`
  * `op_agreements[delegation_id] := nil`
  * `tokens[owner] += tokens_undelegated`

4. The _operator_ is now free to start operating for a new _owner_ and the 
_owner_ can delegate to a new _operator_.

==== An N-to-N variant note
In the _n-to-n_ variant the `staking[owner]` and `operating[operator]` tables
are absent.

=== Operating on a stake

1. When the _operator_ tries to join an operation (eg. present a ticket for
beacon group selection) they should create a _operation initialization order_
including the _delegation ID_ and the _contract address_, signed by the
_operator_.

2. The _operation initialization order_ is published along with any other data
required to join the operation, after which the following should be checked
(`d_agreement := op_agreements[delegation_id]`:
  * `d_agreement != nil`
  * `d_agreement.state == Active`
  * If there is a requirement that the operator be staked before _deadline_,
  then `d_agreement.since =< deadline`
  * The request is signed by `d_agreement.operator`
  * `d_agreement.amount >= minimum_stake`
  * (for atomic alternative) `d_agreement.free_tokens >= minimum_stake`

3. If the checks pass, the operator may join the operations, (for atomic 
alternative) the `lock` method should be used to lock the `minimum_stake` for
the operation and the `unlock` method should be used after the end of the
operation.

=== Rewards

1. If the operator is awarded a _reward_ of currency, the reward should be paid
to `d_agreement.magpie`.

=== Penalties

1. If the operator is to be punished by stake slashing, the
_penalizing contract_ should call the _delegation contract_ with the _penalty_.
The _penalty_ should contain the following:
  * The _penalty amount_
  * The _delegation ID_ to be slashed

2. The _delegation contract_ should then check the following
(`d_agreement := op_agreements[delegation_id]`):
  * `penalty_amount =< minimum_stake`

3. If the penalty is valid, the _delegation contract_ will then perform the
following:
  * `actual_penalty := min(penalty_amount, d_agreement.amount)`
  * `d_agreement.amount -= actual_penalty`
  * If `d_agreement.amount < minimum_stake`, then the operator is blocked from
joining any new operations and the tokens are automatically unstaked:
    ** `d_agreement.state := Unstaking`
    ** `d_agreement.since := current_time`

3. (for atomic alternative instead of the above) If the penalty is valid, the
_delegation contract_ will then perform the following:
  * verify that the locked tokens have been released
  `locked_tokens[contract_address] == nil`
  * `d_agreement.amount -= penalty_amount`

[bibliography]
== Related Links
- Link to the RFC with stake delegation requirements