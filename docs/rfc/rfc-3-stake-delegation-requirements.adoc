:toc: macro

= RFC 3: Stake delegation requirements

:icons: font
:numbered:
toc::[]

== Background

Keep tokens are going to be staked by having token owners delegate their staked
balance to an operator account and use it to run the Keep Client. The operator
account cannot access the stake directly, nonetheless, it operates on behalf of
the owner and bad acting will result in slashing the owners' stake. The operator
may be a third party, or it may be a different address controlled by the owner,
or it may be the same address that owns the tokens.

The stake delegation will be beneficial for the security of Keep users as it
allows on-stake operations with a "cold wallet". Thus, putting Keep users
wallets offline protects them from "hacks" and stake delegation enables
continuous rewarding on safe operations on staked assets. Also exposure of
Keep users private keys will be limited. 

=== Terminology

owner:: The address of an owner of the staked tokens.

operator:: The address of a party authorized to operate a stake in the name of a
  given _owner_.

magpie:: The address where the incentives are sent, earned by an _operator_ in
  the name of an _owner_.

delegated stake:: All of _owner_ staked tokens delegated to the _operator_ .

== Proposal

Stake delegation enables a token _owner_ to delegate their already-staked tokens
to an _operator_ and enables an _operator_ to operate staked tokens in the name
of the _owner_. The owner defines also a _magpie_ address (recipient) where all
incentives generated by the _operator_ on the staked tokens are uploaded.

=== Goal

The goal of this proposal is to specify a simple and secure stake delegation
mechanism. It should enable Keep users to have their wallets offline and their
stake operated by operators on their behalf. The Keep client software should
be able to run without exposing Keep users private keys. 

=== Option 1: Stake delegation with stake atomicity

==== General requirements:
1. _owner_ can only have one operator.
2. _owner_ can only delegate all of his stake.
3. _operator_ cannot have any stake of his own.
4. _operator_ cannot have any tokens at all.
5. _operator_ can only have a _delegated stake_ from only one _owner_.
6. If an _owner_ tries to delegate to more than one operator, the tx must
fail.
7. If an _owner_ tries to delegate a stake to an _operator_ who already has a
stake, the tx must fail.
8. If an _operator_ tries to operate on a stake that he already operates on, the
tx must fail.
9. _delegated stake_ is locked until a particular operation initiated by the
_operator_ ended.
10. The end of an _on stake operation_ happens only after all rewards are
granted and all penalties are imposed. 
11. Rewarding and penalization happens as the last phase of all operations.

==== Stake changes atomicity
By implementing this proposal we are going to enforce the stake changes 
atomicity. It means that the stake cannot be changed during an on stake
operation. When an operator starts to perform an operation (enters a game) on
the delegated stake, then the stake is locked and no other operations are
possible to be done on it (requirement 8.). Releasing delegated stake and
enabling its usage for next operations is possible only after the game ends
(requirement 9.). The end of the game happens only after all slashing and
rewarding are done (requirement 10.) and it is the last phase of all of the
games (requirement 11.). The operator can only have one delegated stake
(requirement 5.), the owner can delegate only to one operator (requirement 1.),
and there cannot be more than one on-stake operation at the same time
(requirement 8.), then there is always a one-to-one relation between the owner,
stake, operator, and a game. Therefore, during a game, the stake can only be
changed as a result of slashing which only occurs at the end of the game.

==== Functionality

===== Delegating a stake:
1. The _owner_, signs a contract where he delegates all of his stake to an
_operator_ address (who will be operating on the __delegated stake_) and a
_magpie_ address (where the rewards will be sent).
2. The _operator_, agrees to the contract, hence making it effective and starts
operating on the __delegated stake_.
3. If there will be no acceptance from the _operator_ until a timeout, then the
__delegated stake_ needs to be returned to the _owner_. In that case the _owner_
needs to be informed.

===== Undelegating a stake:
1. The _owner_/_operator_ initiates undelegation of the _delegated stake_.
2. The _delegated stake_ is locked for a period necessary to finish the 
operation already initiated by the _operator_. No new actions are possible on a
locked stake until the timeout.
3. After a timeout _delegated stake_ is unlocked and transferred to the _owner_.

===== Operating on a stake:
Any operation on a stake needs to start from presenting a valid stake delegation
certificate. All of the parties (_operators_) participating in a particular
operation are required to validate each other's certificates.

To validate the certificate, it is necessary to verify:

- if the contract is valid, (properly signed)
- if the _operator_ is correct, (is signed by the same party which is presenting
the contract)
- if the _owner_ is correct,
- if the _magpie_ is correct,
- if _delegated stake_ is at least _minimum stake_.

The _delegated stake_ is taken from the on-chain data of the _owner_. This value
should not be explicitly written in the contract.

The incentives need always to be sent to the correct _magpie_ address.

The penalties/slashing need always to be done on the correct _owner_ address.

==== Discussion
The _stake delegation with stake atomicity_ enforces only one on-stake operation
at a time. It limits the network throughput and rewarding but also penalization.
Preserving stake atomicity reduces the risk of depleting the _owners_ stake by
misbehaving _operator_ or due to the _undelegating_ the stake.

=== Option 2: Stake delegation with multioperation

==== General requirements:
1. _owner_ can only have one operator.
2. _owner_ can only delegate all of his stake.
3. _operator_ cannot have any stake of his own.
4. _operator_ cannot have any tokens at all.
5. _operator_ can only have a _delegated stake_ from only one _owner_.
6. If an _owner_ tries to delegate to more than one operator, the tx must
fail.
7. If an _owner_ tries to delegate a stake to an _operator_ who already has a
stake, the tx must fail.
8. Rewarding and penalization happens as the last phase of all operations.

==== Stake multioperation
The stake multioperation feature enables performing several operations on the
same stake at the same time. As the stake is not locked for any particular
operation then it is possible for the _operator_ to participate in more than one
parallel operation using the same stake.

==== Functionality

===== Delegating a stake:
1. The _owner_, signs a contract where he delegates all of his stake to an
_operator_ address (who will be operating on the __delegated stake_) and a
_magpie_ address (where the rewards will be sent).
2. The _operator_, agrees to the contract, hence making it effective and starts
operating on the __delegated stake_.
3. If there will be no acceptance from the _operator_ until a timeout, then the
__delegated stake_ needs to be returned to the _owner_. In that case the _owner_
needs to be informed.

===== Undelegating a stake:
1. The _owner_/_operator_ initiates undelegation of the _delegated stake_.
2. All of the on-stake on-going operations are immediately ended. And for these,
the penalties are imposed as usual on the _owners_ stake.
3. After penalization, the stake is returned to the _owner_.

===== Operating on a stake:
Any operation on a stake needs to start from presenting a valid stake delegation
certificate. All of the parties (_operators_) participating in a particular
operation are required to validate each other's certificates.

To validate the certificate, it is necessary to verify:

- if the contract is valid, (properly signed)
- if the _operator_ is correct, (is signed by the same party which is presenting
the contract)
- if the _owner_ is correct,
- if the _magpie_ is correct,
- if the _delegated stake_ is at least the _minimum_stake_ necessary for
starting and continuing on-stake operation.

The _delegated stake_ is taken from the on-chain data of the _owner_. This value
should not be explicitly written in the contract.

The incentives need always to be sent to the correct _magpie_ address.

The penalties/slashing need always to be done on the correct _owner_ address.

If _delegated stake_ falls bellow _minimum stake_ for a particular operator then
his participation in the operation needs to be ended immediately and adequate
slashing needs to be applied.

If an _undelegation_ is invoked for a particular operator, then his
participation in the operation needs to be ended immediately and adequate
slashing needs to be done.

==== Discussion
The _stake delegation with multioperation_ improves overall network throughput
due to the possibility to participate in many concurrent operations at the same
time. The _delegated stake_ is in multiple operations at the time and the
_owner_ will be rewarded for all of them. The same applies to the penalization
and if the _operator_ will misbehave for all of his operations the _owner_ stake
will be slashed adequately. Therefore, the multioperation feature can be
compared to an investing lever where _owner_ can gain a lot and lose a lot.
Also, there is an _undelegation_ cost issue where the cost of the _undelegation_
might be higher than the _delegated stake_ due to performing too many operations
by the _operator_. Therefore, it might be possible to _lock_ an _owner_ to an
_operator_ by performing so many operations at the same time by the _operator_
that ending penalties cost would be higher than stake (or economically
unprofitable).

=== Option 3: Stake delegation with sub-stake atomicity and limited multioperation

==== General requirements:
1. _owner_ can only delegate all of his stake.
2. _owner_ can divide his _delegated stake_ into a number of _sub-stakes_.
3. _owner_ can only have one operator per _sub-stake_.
4. _operator_ cannot have any stake of his own.
5. _operator_ cannot have any tokens at all.
6. _operator_ can only have a _delegated stake_ from only one _owner_.
7. If an _owner_ tries to delegate his _sub-stake_ to more than one operator,
the tx must fail.
8. If an _owner_ tries to delegate a stake to an _operator_ who already has a
stake, the tx must fail.
9. If an _operator_ tries to operate on a stake that he already operates on, the
tx must fail.
10. _delegated stake_ is locked until a particular operation initiated by the
_operator_ ended.
11. The end of an _on stake operation_ happens only after all rewards are
granted and all penalties are imposed. 
12. Rewarding and penalization happens as the last phase of all operations.

==== Sub-stake atomicity
By implementing this proposal we are going to enforce the sub-stake atomicity.
It means that the stake cannot be changed during an on stake operation. When an
operator starts to perform an operation (enters a game) on the delegated 
_sub-stake_, then the stake is locked and no other operations are possible to be
done on it (requirement 9.). Releasing delegated stake and enabling its usage
for next operations is possible only after the game ends (requirement 10.). The
end of the game happens only after all slashing and rewarding are done 
(requirement 11.) and it is the last phase of all of the games (requirement
12.). The operator can only have one delegated _sub-stake_ (requirement 6.), the
owner can delegate _sub-stake_ to only to one operator (requirement 3.), and
there cannot be more than one on-_sub_stake_ operation at the same time
(requirement 8.), then there is always a one-to-one relation between the owner,
sub-stake, operator, and a game. Therefore, during a game, the stake can only be
changed as a result of slashing which only occurs at the end of the game.

==== Limited multioperation
The limited stake multioperation feature enables performing a limited number of
operations on the same stake at the same time. As the stake is divided into many
_sub-stakes_ which are locked individually for a particular operation,
therefore, it is possible for the _operator_ to participate in more the number
of parallel operations limited by the number of _sub-stakes_.

==== Functionality

===== Delegating a stake:
1. The _owner_, signs a contract where he delegates his _sub-stake_ to an
_operator_ address (who will be operating on the __delegated stake_) and a
_magpie_ address (where the rewards will be sent).
2. The _operator_, agrees to the contract, hence making it effective and starts
operating on the __delegated stake_.
3. If there will be no acceptance from the _operator_ until a timeout, then the
__delegated stake_ needs to be returned to the _owner_. In that case the _owner_
needs to be informed.

===== Undelegating a stake:
1. The _owner_/_operator_ initiates undelegation of the _delegated stake_.
2. The _delegated stake_ is locked for a period necessary to finish the 
operation already initiated by the _operator_. No new actions are possible on a
locked stake until the timeout.
3. After a timeout _delegated stake_ is unlocked and transferred to the _owner_.

===== Operating on a stake:
Any operation on a stake needs to start from presenting a valid stake delegation
certificate. All of the parties (_operators_) participating in a particular
operation are required to validate each other's certificates.

To validate the certificate, it is necessary to verify:

- if the contract is valid, (properly signed)
- if the _operator_ is correct, (is signed by the same party which is presenting
the contract)
- if the _owner_ is correct,
- if the _magpie_ is correct,
- if the _delegated sub-stake_ is at least the _minimum_stake_ necessary for
starting and continuing on-stake operation.

The _delegated sub-stake_ is taken from the on-chain data of the _owner_. This 
value should not be explicitly written in the contract.

The incentives need always to be sent to the correct _magpie_ address.

The penalties/slashing need always to be done on the correct _owner_ address.

==== Discussion
The _stake delegation with stake atomicity and limited multioperation_ enables
better throughput than the _stake delegation with atomicity_ due to dividing
stake into a number of _sub-stakes_ that can be operated on in parallel. It is
also safer than the _stake delegation with multioperation_ due to the
possibility of limiting the number of concurrent on-stake operation to the
number of _sub-stakes_.

=== Option 4: Stake delegation with somewhat stake atomicity and limited multioperation

==== General requirements:
1. _owner_ can only have one operator.
2. _owner_ can only delegate all of his stake.
3. _operator_ cannot have any stake of his own.
4. _operator_ cannot have any tokens at all.
5. _operator_ can only have a _delegated stake_ from only one _owner_.
6. If an _owner_ tries to delegate to more than one operator, the tx must
fail.
7. If an _owner_ tries to delegate a stake to an _operator_ who already has a
stake, the tx must fail.
8. The end of an _on stake operation_ happens only after all rewards are
granted and all penalties are imposed. 
9. Rewarding and penalization happens as the last phase of all operations.

==== Somewhat stake atomicity
The somewhat stake atomicity protects the stake by limiting the number of
concurrent operations to the `DELEGATED_STAKE / MINIMUM_STAKE` and locking the
_MINIMUM_STAKE_ per each operation the stake (through the _operator_) is
participating.

==== Limited multioperation
The limited stake multioperation feature enables performing several operations
on the same stake at the same time. As only part of the stake is locked per
particular operation, then it is possible for the _operator_ to participate in
more than one parallel operation limited by the `DELEGATED_STAKE / 
MINIMUM_STAKE`.

==== Functionality

===== Delegating a stake:
1. The _owner_, signs a contract where he delegates all of his stake to an
_operator_ address (who will be operating on the __delegated stake_) and a
_magpie_ address (where the rewards will be sent).
2. The _operator_, agrees to the contract, hence making it effective and starts
operating on the __delegated stake_.
3. If there will be no acceptance from the _operator_ until a timeout, then the
__delegated stake_ needs to be returned to the _owner_. In that case the _owner_
needs to be informed.

===== Undelegating a stake:
1. The _owner_/_operator_ initiates undelegation of the _delegated stake_.
2. All of the on-stake on-going operations are immediately ended. And for these,
the penalties are imposed as usual on the _owners_ stake.
3. After penalization, the stake is returned to the _owner_.

===== Operating on a stake:
Any operation on a stake needs to start from presenting a valid stake delegation
certificate. All of the parties (_operators_) participating in a particular
operation are required to validate each other's certificates.

To validate the certificate, it is necessary to verify:

- if the contract is valid, (properly signed)
- if the _operator_ is correct, (is signed by the same party which is presenting
the contract)
- if the _owner_ is correct,
- if the _magpie_ is correct,
- if the _delegated stake_ is at least the _minimum_stake_ necessary for 
starting on-stake operation.

The _delegated stake_ is taken from the on-chain data of the _owner_. This value
should not be explicitly written in the contract.

When starting an operation a _MINMUM_STAKE_ needs to be blocked to ensure
correct participation in a particular operation. The _MINIMUM_STAKE_ value needs
to be subtracted from the _delegated stake_ and locked until the end of the
operation. Therefore, the number of concurrent operations is limited to the
stake divided by the _MINIMUM_STAKE_ and all operations are protected and
validated by the locked stake.

The incentives need always to be sent to the correct _magpie_ address.

The penalties/slashing need always to be done on the correct _owner_ address.

If an _undelegation_ is invoked for a particular operator, then his
participation in the operation needs to be ended immediately and adequate
slashing needs to be done.

==== Discussion
The _stake delegation with somewhat stake atomicity and limited multioperation_
enables better network throughput than the _stakte delegation with stake
atomicity_. It protects the stake better than the _stake delegation with
multioperation_ as it limits the number of concurrent operations and prohibits
the situation when the stake would go below the _MINIMUM_STAKE_ during the 
operation.

Depending on the way the sub-staking is done it can achieve similar network
throughput and safety as the _stake delegation with sub-stake atomicity and
limited multioperation_.

== Open Questions

How is this going to interact with RFC 4 (on secure upgrades)?

Can we have different stake delegation contracts at the same time? - The
mechanics of proposed contracts might not be conflicting with each other and it
might be beneficial to have parallel contract types fulfilling the particular
needs of our users.

=== Penalization:
How to penalise misbehaviour?

Should an _operator_ have an accountable address which will be slashed?

=== Timeouts:
What timeouts are reasonable?

== Future work
Consider how the stake delegation will interact with ETH bonding (part of Keep,
but not the beacon).

[bibliography]
== Related Links
- https://www.flowdock.com/app/cardforcoin/tech/threads/UQhnqrQAWk3azp2TO9UhOJQRMXp
- https://www.flowdock.com/app/cardforcoin/keep/threads/TA-Jwe9oMaOBAylc3yRJObc5Bq_
- https://www.flowdock.com/app/cardforcoin/keep/threads/k6MV7jS9DEd0DnvOpkAt5SjsS9w
- https://www.flowdock.com/app/cardforcoin/tech/threads/-Lbr4JzmX0gY31CMDTRGnQUbbuw
- https://github.com/keep-network/keep-core/pull/121