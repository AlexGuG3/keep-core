= RFC ##: draft-keep-network-layer-security

:icons: font
:numbered:
toc::[]

== Background

This document describes a protocol to secure the network layer of the Keep
Network. This involves verifying identities (to prevent sybill attacks), ensuring
message integrity (to avoid mallicious tampering), and encrypting messages (to
ensure that only intended recipients receive a message).

Keep is both a decentralized application that lives on a host chain, and a
layer two network which fulfills the requests of the application. To ensure the
safety, security, and integrity of the network, the network needs to implement
authorization, encryption, and authentication. The decentralized nature of the
network brings about the unique challenege where off-the-shelf protocols such as
TLS can't be used due to the lack of trusted third parties and intermediaries.

This presents an opportunity to survey the current available protocols, and
identify which pieces best fit the requirements of the layer 2 network.


=== Current Functionality

Currently, we do neither of authenticating identities and encrypting messages
in our network. This limits our ability to restrict access to mallicious actors,
prevents our messages from being tamper-resistant, and allows sensitive information
to be seen in the clear. This document attempts to provide a path forward.

== Proposal

=== Terminology

* client: the initiator of a secure connection.
* server: the receiver of a secure connection.
* peer: a member of a network that is both a client and a server.
* network: connections between many peers, not necissarily p2p.
* handshake: an initial negotiation between a client and a server to establish
secret key material.
* chain: a decentralized, consensus driven store with identities and economic
incentives.
* stake: an on-chain identity that holds at least the minimum amount of value
required to be a participant in the network.
* bootstrap: a trusted peer in a network that facilitates new connections into the network from untrusted peers by verifying an on-chain stake.

=== Goal

We aim to authenticate peers, control access to a network where Keepâ€™s protocols
execute, and provide a secure channel between two communicating peers. The
protocol must provide the following properties:

- Authentication:
The goal of authentication is to provide the communicating parties with some
assurance that they know each others identities.

In our model of authentiation, every node is a server and a client, and all nodes
must always be authenticated. Authentication happens via asymmetric cryptography,
using a signature algorithm that is cheap to verify on-chain (ie. ECDSA, BLS).
The client must provide the server proof of attestation over a staked key on chain.

- Authorization:
The goal of authorization is to ensure that capabilities within the system are
restricted to authenticated identities

The only capabilities a node has before establishing a secure, authenticated
connection is sending an initialization message, ClientHello, to a node that can
process this message and authenticate the node. Authenticated nodes can
participate in the network and form secure channels with other authenticated
members.

- Confidentiality: Data sent over wire via the established secure channel is only
visible to the communicating peers.

- Integrity: Data sent over the channel after establishment cannot be modified by
adversaries without detection.

The protocol should be flexible enough to satisfy the following (but not limited to) scenarios:

* A client wants to become a peer in the Keep Network. A client must be, first
and formost, successfully staked (otherwise dishonest participants can't be
punished). Furthermore, the client must prove their stake to the members of the
network.

* A client wishes to send a point-to-point message such that only the intended
recipient can inspect and verify the contents of the message.

- A packed message P that contains many sub-messages S, each signed and encrypted
for a specific member M. This message can be circulated throughout a network such
that all intended recipients will eventually receive the message BUT will be only
be able to unpack the contents of a sub-message intended for them (M can read S in P).


=== Potential Implementations

There are four implementations we can explore given the above constraints:

Building Blocks

==== Elliptic-Curve-Diffie-Hellman
===== Overview
        - [draft]Diffie-Hellman satisifys some of the properties above, but due to [reasons],
        it does not assume the presence of signature keys and hence is susceptible
        to MITM attacks. As a building block, we can take this into account and layer on-top
     signing keys. This introduces complexity to the protocol, though.

===== Limitations

==== Station-to-Station
===== Overview
- The base spec concerns with exponentiation, but also applies equally well to additive groups (ec over finite fields).
- Authenticated key agrement with key confirmation: two-way explicit key confirmation

===== Limitations
* This is only a cryptographic key agreement scheme
* Still vulnerable to a mitm attack if the persistent signing keys aren't known
in advance. Fortunately, we can use staked keys or X509 certs generated from
those staked keys to ensure that both parties are known before hand.


==== Noise Protocol
===== Overview

===== Limitations


Frameworks
==== TLS
===== Overview
===== Limitations

==== Custom
===== Overview
===== Limitations

== Future Work (optional)

If applicable, what future evolutions could you see this approach leading to?
Particularly if these possibilities influenced your thinking about the main
proposal, this is important.

== Open Questions (construction section for Raghav :hammer:)

Does our protocol need to be application independent? Application protocol indepedent?
Do we need to expect that other higher-level protocols will be layered on top?
we need forward secrecy - how will we get that?

What messages are in the clear? In any handshake, does the first message
(ClientHello) have to be in the clear? Or can we state that the first message to
the bootstrap node is encrypted with the bootstrap node's Public Key? And then
the return (ServerHello) is encrypted with the client's pubkey.

No need for point format negotiation, right? Single point format for each curve.

Are we at risk of version downgrade if we support more than one negotiation type?
What does a non bootstrap node do with an authentication message? Or, does a
non bootstrap node accept a connection even if the node in question isn't known
authenticated via a bootstrap node?

Datagram-based transports have a terrible story (DTLS) - noise protocol is an obvious winner here.

Noise protocol makes a lot of sense for situations where you've committed to not using TLS and embarking on a custom protocol.

TLS requires that communicating participants be online.

There is no "constant" rekeying in TLS - typically you use the same key that's
established for the lifetime because connections are short lived.
That being said, you can explicitly rekey if you'd like.

TLS has very low overhead; ideal for things that are significantly lower powered than phones).

[bibliography]
== References

- [[[TLS]]] E Rescorla, Mozilla, August 2018
The Transport Layer Security (TLS) Protocol Version 1.3
https://www.rfc-editor.org/rfc/rfc8446.txt
