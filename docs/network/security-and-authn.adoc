= RFC ##: draft-keep-network-layer-security

:icons: font
:numbered:
toc::[]

== Background
Keep is a decentralized network that is anchored to one or more host chains via
on-chain smart contracts, allowing interactions both on- and off-chain depending
on the use case. To ensure the safety, security, and integrity of the network,
the network needs to implement authorization, encryption, and authentication. The
decentralized nature of the network brings about the unique challenge where
off-the-shelf protocols such as TLS can't be used due to the lack of trusted
central authorities and intermediaries.

This document specifies requirements, surveys current available protocols, and
describes a protocol to secure the network layer of Keep.

A successful protocol involves verifying identities (to prevent Sybil attacks),
ensuring message integrity (to avoid malicious tampering), and encrypting
messages (to ensure that only intended recipients receive a message).


=== Terminology

peer:: A member of a network that can initiate, accept, and handle secure
connections.
network:: Connections between many peers, not necessarily p2p.
handshake:: An initial negotiation between peers to establish secret key
material.
chain:: A decentralized, consensus driven store with identities and economic
incentives.
stake:: The amount of value required to be a participant in the network. This
amount is held on the host chain and associated with an identity.
bootstrap node:: A trusted peer in a network that facilitates new connections
into the network from untrusted peers by verifying an on-chain stake.


=== Goal

We aim to authenticate peers, control access to a network where Keepâ€™s protocols
execute, and provide verifiable, private channels between communicating peers.
The protocol must provide the following capabilities:

- Authentication:
The goal of authentication is to provide the communicating parties with some
assurance that they know each others identities. If the authentication involves
key exchange, then they both accept the exchanged key also.

In our model of authentication, all peers must always be authenticated.
Authentication happens via asymmetric cryptography, using a signature algorithm
that is cheap to verify on-chain (ie. ECDSA, BLS). Given an authenticated peer
and an unauthenticated peer, the unauthenticated peer must provide the
authenticated peer proof of attestation over a staked key on chain.

- Authorization:
The goal of authorization is to ensure that capabilities within the system are
restricted to authenticated identities.

The only capabilities a peer has before establishing a secure, authenticated
connection is sending an initialization message, referred to as the
AuthenticationMessage, to a peer that can process this message and authenticate
the peer. Authenticated peers can participate in the network and form secure
channels with other authenticated members.

And have the following properties:

- Confidentiality: Data sent over wire via the established secure channel is only
intelligible to the communicating peers.

- Integrity: Data sent over the channel after establishment cannot be modified by
adversaries without detection.

- Attributability: A message from a given peer is known to be from that peer.

==== Scenarios

The protocol should be flexible enough to satisfy the following (but not limited to)
scenarios:

* An unauthenticated peer wants to become an authenticated peer in the Keep
Network. This peer must be, first and foremost, successfully staked (otherwise
dishonest participants can't be punished). Furthermore, the peer must prove their
stake to the members of the network.

* A peer wishes to send a point-to-point message such that only the intended
recipient can inspect and verify the contents of the message.

* A packed message P that contains many sub-messages S, each signed and encrypted
for a specific member M. This message can be circulated throughout a network such
that all intended recipients will eventually receive the message BUT will be only
be able to unpack the contents of a sub-message intended for them
(M can read S in P).


=== Potential Implementations

Given the above, we are primarily concerned with authentication and key exchange.
The literature overwhelmingly recommends a solution which provides authentication
and key-exchange considered jointly. Per <<Station-To-Station>>:

> A protocol providing authentication without key exchange is susceptible to an
> enemy who waits until the authentication is complete and then takes over one
> end of the communications line. Such an attack is not precluded by a key
> exchange that is independent of authentication. Key exchange should be linked
> to authentication so that a party has assurances that an exchanged key (which
> might be used to facilitate privacy or integrity and thus keep authenticity
> alive) is in fact shared with the authenticated party, and not an impostor. For
> these reasons, it is essential to keep key exchange in mind in the design and
> analysis of authentication protocols.

There are a few implementations we can explore given the above constraints:


==== Elliptic-Curve-Diffie-Hellman

===== Overview
        - [draft]Diffie-Hellman satisfies some of the properties above, but due
        to [reasons], it does not assume the presence of signature keys and hence
        is susceptible to man-in-the-middle attacks. As a building block, we can
        take this into account and layer on-top signing keys. This introduces
        complexity to the protocol.

===== Limitations


==== Elliptic Curve, Diffie-Hellman Full Station-to-Station

===== Overview

- The base spec concerns with exponentiation, but also applies equally well to additive groups
(ec over finite fields).
- Authenticated key agreement with key confirmation: two-way explicit key confirmation

===== Limitations

* This is only a cryptography key agreement scheme
* Still vulnerable to a man-in-the-middle attacks if the persistent signing keys
aren't known in advance. Fortunately, we can use staked keys or X509 certs
generated from those staked keys to ensure that both parties are known before
hand.


==== Noise Protocol

===== Overview

===== Limitations


==== TLS

===== Overview

===== Limitations

==== Custom

===== Overview

===== Limitations


== Future Work (optional)

If applicable, what future evolutions could you see this approach leading to?
Particularly if these possibilities influenced your thinking about the main
proposal, this is important.


== Open Questions (construction section for Raghav :hammer:)

Does our protocol need to be application independent? Application protocol independent?
Do we need to expect that other higher-level protocols will be layered on top?
we need forward secrecy - how will we get that?

What messages are in the clear? In any handshake, does the first message
(ClientHello) have to be in the clear? Or can we state that the first message to
the bootstrap node is encrypted with the bootstrap node's Public Key? And then
the return (ServerHello) is encrypted with the sender of the ClientHello's pubkey.

No need for point format negotiation, right? Single point format for each curve.

Are we at risk of version downgrade if we support more than one negotiation type?
What does a non bootstrap node do with an authentication message? Or, does a
non bootstrap node accept a connection even if the peer in question isn't known
authenticated via a bootstrap node?

Datagram-based transports have a terrible story (DTLS) - noise protocol is an obvious winner here.

Noise protocol makes a lot of sense for situations where you've committed to not using TLS and embarking on a custom protocol.

TLS requires that communicating participants be online.

There is no "constant" rekeying in TLS - typically you use the same key that's
established for the lifetime because connections are short lived.
That being said, you can explicitly rekey if you'd like.

TLS has very low overhead; ideal for things that are significantly lower powered than phones).


[bibliography]
== References

- [[[TLS]]] E Rescorla, Mozilla, August 2018
The Transport Layer Security (TLS) Protocol Version 1.3
https://www.rfc-editor.org/rfc/rfc8446.txt
