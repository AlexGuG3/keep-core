= RFC ##: draft-keep-network-layer-security

:icons: font
:numbered:
toc::[]

== Background

Keep is a decentralized network that is anchored to one or more host chains via
on-chain smart contracts, allowing interactions both on- and off-chain depending
on the use case. To ensure the safety, security, and integrity of the network,
the network needs to implement authorization, encryption, and authentication. The
decentralized nature of the network brings about the unique challenge where
off-the-shelf protocols such as TLS aren't suitable. Specifically, these
protocols can't be used as-is due to their requirement of trusted central
authorities and intermediaries.

This document specifies requirements, surveys current available protocols, and
describes a protocol to secure the network layer of Keep.

A successful protocol involves verifying identities (to prevent Sybil attacks),
ensuring message integrity (to avoid malicious tampering), and encrypting
messages (to ensure that only intended recipients receive a message).


=== Terminology

peer:: A member of a network that can initiate, accept, and handle secure
connections.
network:: Connections between many peers, not necessarily p2p.
handshake:: An initial negotiation between peers to establish secret key
material.
chain:: A decentralized, consensus driven store with identities and economic
incentives.
stake:: The amount of value required to be a participant in the network. This
amount is held on the host chain and associated with an identity.
bootstrap node:: A trusted peer in a network that facilitates new connections
into the network from untrusted peers by verifying an on-chain stake.


=== Goal

We aim to authenticate peers, control access to a network where Keepâ€™s protocols
execute, and provide verifiable, private channels between communicating peers.
The protocol must provide the following capabilities:

- Authentication:
The goal of authentication is to provide the communicating parties with some
assurance that they know each others identities. If the authentication involves
key exchange, then they both accept the exchanged key also.

In our model of authentication, all peers must always be authenticated.
Authentication happens via asymmetric cryptography, using a signature algorithm
that is cheap to verify on-chain (ie. ECDSA, BLS). Given an authenticated peer
and an unauthenticated peer, the unauthenticated peer must provide the
authenticated peer proof of attestation over a staked key on chain.

- Authorization:
The goal of authorization is to ensure that capabilities within the system are
restricted to authenticated identities.

The only capabilities a peer has before establishing a secure, authenticated
connection is sending an initialization message, referred to as the
AuthenticationMessage, to a peer that can process this message and authenticate
the peer. Authenticated peers can participate in the network and form secure
channels with other authenticated members.

And have the following properties:

- Confidentiality: Data sent over wire via the established secure channel is only
intelligible to the communicating peers.

- Integrity: Data sent over the channel after establishment cannot be modified by
adversaries without detection.

- Attributability: A message from a given peer is known to be from that peer.


=== Scenarios

The protocol should be flexible enough to satisfy the following (but not limited to)
scenarios:


==== Joining

An unauthenticated peer wants to become an authenticated peer in the Keep
Network. This peer must be, first and foremost, successfully staked (otherwise
dishonest participants can't be punished). Furthermore, the peer must prove their
stake to the members of the network.

The capabilities, authentication and authorization, cover the requirements
of this example. Specifically, authentication allows a peer to validate the
identity of the unknown peer. Next, authorization enables the following:

1. The restriction of the unknown, untrusted peer to only send the initial
request to be authenticated.
2. The capability of an authenticated peer to respond to on-chain events or to
network-specific events.
3. The restriction (and potential disconnection) from the network for members
who fall below the minimum stake or for those who act maliciously.


==== Point-to-Point

A peer wishes to send a point-to-point message such that only the intended
recipient can inspect and verify the contents of the message.

This example presumes that the identity is verified and accepted in the network,
which means that authentication and authorization are satisfied.
Confidentiality is needed to ensure that the communicating peers can communicate
in secret. Integrity to ensure that the message hasn't been tampered with in
transit over the wire. Attributability to ensure that if the either peer means
the other harm, then they will be removed from the network.


==== Message Gossip

A packed message _M_ that contains many sub-messages _S~all~_, each signed and
encrypted for a specific peer _P~i~_. This message _M_ can be circulated
throughout a network such that all intended recipients _P~all~_ will eventually
receive the message _M_ BUT will be only be able to unpack the contents of a
sub-message _S~i~_ intended for them (_P~i~_ can read _S~i~_ in _M_).

This example will require all of confidentiality, integrity, and attributability.

Confidentiality ensures that each sub-message _S~i~_ is signed and encrypted for
the use of a specific peer _P~i~_.

Integrity ensures that no other peer _P~1~_ can successfully tamper with another
peer's _P~2~_ message _S~2~_(as many peers will be exposed to the same message _M_,
but only have access to a specific sub-message _S~i~_).

Attributability ensures that if a peer acts in bad faith, they are easily
identifiable by any other authenticated peer in the network.


=== Potential Implementations

Given the above, we are primarily concerned with authentication and key exchange.
The literature overwhelmingly recommends a solution which provides authentication
and key-exchange considered jointly. Per <<AAKE>>:

> A protocol providing authentication without key exchange is susceptible to an
> enemy who waits until the authentication is complete and then takes over one
> end of the communications line. Such an attack is not precluded by a key
> exchange that is independent of authentication. Key exchange should be linked
> to authentication so that a party has assurances that an exchanged key (which
> might be used to facilitate privacy or integrity and thus keep authenticity
> alive) is in fact shared with the authenticated party, and not an impostor. For
> these reasons, it is essential to keep key exchange in mind in the design and
> analysis of authentication protocols.

There are a few implementations we can explore given the above constraints:


==== Elliptic-Curve-Diffie-Hellman

===== Overview
        - [draft]Diffie-Hellman satisfies some of the properties above, but due
        to [reasons], it does not assume the presence of signature keys and hence
        is susceptible to man-in-the-middle attacks. As a building block, we can
        take this into account and layer on-top signing keys. This introduces
        complexity to the protocol.

===== Limitations


==== Elliptic Curve, Diffie-Hellman Full Station-to-Station

===== Overview

- The base spec concerns with exponentiation, but also applies equally well to additive groups
(ec over finite fields).
- Authenticated key agreement with key confirmation: two-way explicit key confirmation

===== Limitations

* This is only a cryptography key agreement scheme
* Still vulnerable to a man-in-the-middle attacks if the persistent signing keys
aren't known in advance. Fortunately, we can use staked keys or X509 certs
generated from those staked keys to ensure that both parties are known before
hand.


==== Noise Protocol

===== Overview

===== Limitations


==== TLS

===== Overview

===== Limitations

==== Custom

===== Overview

===== Limitations


== Open Questions

* Does our protocol need to be application independent? Application protocol
independent?

* Do we need to expect that other higher-level protocols will be
layered on top?

* Do we require forward secrecy - how will we get that?

* Are we at risk of version downgrade if we support more than one negotiation type?

* What does a non-bootstrap node do with an authentication message?

* Is a requirement for communicating participants that they be online?

[bibliography]
== References

- [[[TLS]]] E Rescorla, Mozilla, August 2018
The Transport Layer Security (TLS) Protocol Version 1.3
https://www.rfc-editor.org/rfc/rfc8446.txt

- [[[AAKE]]] Diffie W. (1992)
Authentication and Authenticated Key Exchanges
In: Designs, Codes and Cryptography, 2, 107-125 (1992), Kluwer Academic Publishers
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.216.6107&rep=rep1&type=pdf
