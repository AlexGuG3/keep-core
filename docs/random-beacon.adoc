:toc: macro

= The Keep Random Beacon: An Implementation of a Threshold Relay

toc::[]

[abstract]
.Abstract
--
The Keep Network requires a trusted source of randomness for the process of Keep
selection. While the network requires that randomness to function correctly, the
source of randomness is itself broadly applicable. This trusted source of
randomness takes the form of a BLS Threshold Relay. We discuss implementation of
this random beacon, including assumptions and mitigations for bad actors and
poor network connectivity.
--


== Overview

 - Goals
 - Organization (core tech, state flow, incentives, ...)
 - Assumptions
 - High-level description

The threshold relay described in this paper is a way of generating verifiable
randomness that is resistant to bad players both in the relay network and on the
anchoring blockchain, assumed here to be Ethereum. The basic functioning of the
relay (further details are in the section on <<System Details>>) is:

 - Some number of groups exist in the relay.
 - An arbitrary seed value `v_s` counts as the first entry in the relay.footnote:[The
   importance, from a security perspective, of the seed value goes away almost
   immediately in a functioning network.]
 - A request `r_i` is dispatched to the chain for a new entry.
 - Information about the request is combined with the previous entry to produce
   a new relay entry seed value `v_r`.
 - `v_r` is used to choose a group to produce the response to the request.
 - `v_r` is signed by at least a subset of the chosen group members, and the
   resulting signature is the entry generated in response to the request. It is
   published to the anchoring blockchain as the entry `v_i`.

The following sections will detail how this basic function is implemented in
practice, including notes on <<Prior Work>> that motivated this design,
the <<Incentive Structures>> used to economically incentivize good behavior by
network participants, <<Core Technologies>> used in the network, and finally the
<<System Details>> that outline the implementation itself. <<Upgrade Management>>
is also discussed, along with <<Anticipated Updates>> to the network in the near
term.

.Keep Threshold Relay
image::img/generated/relay-diagram.png[Diagram of the Keep threshold relay]

== Prior Work

Dfinity has described their implementation of a random beacon backed by a
threshold relay in their consensus whitepaper
footnote:[https://dfinity.org/pdf-viewer/library/dfinity-consensus.pdf]. The
relay described in this paper is heavily based on the one devised by the Dfinity
team, with certain adjustments for implementation on an existing blockchain. The
key distinction between the Dfinity implementation and the Keep implementation
is that Keep has to contend with blockchains that do not implement the same
primitives as the in-house Dfinity chain targeted in their paper. Concerns such
as transaction costs and payment for beacon entries are therefore a core part of
the incentive system built around the Keep random beacon.

As described in the above paper, at the heart of the relay beacon is the
signature scheme described by Dan Boneh, Ben Lynn, and Hovav Shacham in
footnote:[D. Boneh, B. Lynn and H. Shacham, “Short signatures from the Weil
pairing”, Advances in Cryptology – ASIACRYPT 2001, Lecture Notes in Computer
Science, 2248 (2001), 514–532. Full version: Journal of Cryptology, 17 (2004),
297–319.], termed BLS. Three properties of the scheme are of particular use in
this case: BLS signatures can be used in _threshold_ mode, where _k_ of _n_
participants are sufficient to produce a combined signature; BLS threshold
signatures produce the same final signature irrespective of the participants;
and BLS signatures are typically shorter than those of many other threshold
signature schemes.

Finally, underpinning the process of generating new groups for BLS threshold
signatures in the system is a distributed key generation algorithm based on work
by Gennaro, Jarecki, Krawczyk, and Rabin footnote:[R. Gennaro, S. Jarecki, H.
Krawczyk, and T. Rabin. Advances in Cryptology — EUROCRYPT ’99: International
Conference on the Theory and Application of Cryptographic Techniques Prague,
Czech Republic, May 2–6, 1999 Proceedings, chapter Secure Distributed Key
Generation for Discrete-Log Based Cryptosystems, pages 295–310. Springer Berlin
Heidelberg, Berlin, Heidelberg, 1999 ;
http://groups.csail.mit.edu/cis/pubs/stasio/vss.ps.gz], as also described in the
Dfinity paper above. The Keep relay beacon publishes group public keys to the
anchoring blockchain and does member selection on-chain, but key generation
occurs between nodes.

== Core Technologies

=== Dependency Management?

- Repo pinning
- Commit-hash-based dependencies

=== Networking

- libp2p
- multiaddr
- floodsub?

=== Messaging

- protobuf
- sig/encryption libs for messages

=== Ethereum

- JSON-RPC

=== BLS Implementation

- bn
- go-dfinity-crypto

== System States

 - State diagrams
 - Details of node state, system state, chain state

== Mechanical Attack Mitigations

The Keep threshold relay is designed to mitigate as many instances of malicious
behavior as possible, as well as to encourage stakers to employ well-networked
and highly available systems for their clients. This is done in two parts:
choosing robust technical implementations (like threshold signatures) that are
resilient to high degrees of misbehavior and network failure, and calibrating
the incentive structure to ensure strong punishments for malicious actions. We
discuss several potential attacks that are mitigated via adjustments to the
mechanics of the system here.

=== Miner, Requestor, and Relay Influence

Let us remember that the most basic construction (discussed in the <<Overview>>)
of a request-based threshold relay uses the previous value mod the number of
active groups to determine the next group. This next group then signs the
previous value to produce the next value. This happens every time a relay entry
(that is, a random number) is requested. There are a few key problems that
manifest in this simple construction:

 - The relay can collude to know random numbers an infinite number of steps
   ahead of the requests.
 - Miners who have compromised a group can collude to censor a request until the
   previous entry would select a group they control.
 - Miners who have compromised a group can collude to censor a request that
   would select the group they control if they know the outcome would not be to
   their advantage.
 - A requestor who has compromised a group can wait to put a request in until
   the previous entry would select a group they control.
 - A requestor who has comporomised a group can wait to put a request in if it
   would select the group they control and the outcome would not be to their
   advantage.

We address each of these below. We assume here that controlling one group is
expensive, and controlling all groups is prohibitively so; see the section on
<<Incentives>> for more on what that requires.

==== Relay Frontrunning

One of the disadvantages of the simple construction above is that future entries
can be computed in advance of their use. For example, if it were known that a
lottery was being held in _N_ blocks, the relay could collude to run ahead that
number of entries so as to have the relay's value before the entry came due. The
Keep implementation of the relay mitigates this by using information about the
request to adjust the previous entry before signing it. In particular, the relay
provides the requestor the ability to specify a _seed_, which is XORed with the
previous entry to allow the requestor to add entropy to the final result.

NOTE: The seed itself must be unpredictable to the relay, or the relay could
still frontrun with the above mitigation; however, the mitigation for miner
censorship below further limits the ability to frontrun.

==== Miner Censorship

Miners can choose not to include a transaction that does not benefit them. For
example, if a given relay request comes in for a lottery the miner is also
participating in, and the group that will be selected is not under their
control, or the group _is_ under their control and they can determine the next
entry would not be favorable to them, the miner could censor the transaction
and effectively get a second chance at winning the lottery. The Keep
implementation of the relay mitigates this by using information from the block
to affect the choice of the group.

A simple implementation here could use the block hash of the request block XORed
with the previous entry, then mod against the number of groups to change the
result. However, miners have some control over block hashes as well. Instead,
the Keep relay waits 2 blocks after the request is seen, and uses these two
block hashes to decide the group. This elevates the requirement to having miners
frontrun by at least 2 blocks before being able to decide to censor a request.

==== Requestor Cheating

The last player in the set of actors involved in a relay interaction is the
requestor. The requestor is given the ability to add entropy to their request by
providing a seed to make the signing value less predictable. However, this also
gives the requestor the potential to influence the final outcome.

So why go forward 2 blocks for group selection instead of looking at a previous
block? If the group selection were based on a prior block, a requestor would
always be able to know which group their request would go to. Since the
requestor specifies a seed that influences the value signed by the selected
group, the requestor could wait to submit a request until they knew the signing
group would be the group the requestor controls. Thus, by mixing in the miner
censorship mitigation, which makes the signing group unpredictable until after
the request is made, we also reduce the requestor's ability to know who the
signing group will be at request time.

=== Denial of Service

Denial of service attacks are a problem in two phases of the relay's operation:
group formation and relay response generation. The relay itself can also be
DoSed by too many requests. The first two in particular share the requirement
that either a player outside or inside the relay be able to know enough about
the clients in a group to launch DoS attacks against them.

 - DoS of the signing group
 - DoS during group creation
 - DoS of the relay

== Incentives

The Keep threshold relay is designed to minimize the amount of trust that needs
to be placed in any individual node in the system. As much as possible, the
mechanics of the relay themselves prevent inappropriate manipulation of the
system, but this can only take us so far, since the individual nodes are run by
unvetted participants. To deal with this, the staking, rewards, and punishment
systems must make honest participation the most lucrative behavior, and make
dishonest behavior as undesirable as possible.

=== Stakes

To participatein the relay, a node must be associated with an account that has
staked a minimum amount of its KEEP. footnote:[The mechanics of discovering and
updating minimum stakes are discussed in the <<System Details>> section.] Note
also that unstaking KEEP intentionally takes an extended period of time (on the
order of weeks). This discourages attacks that will reduce the value of the KEEP
token, since such attacks will also cost a staker at least the minimum stake's
value.

The minimum stake is carefully calibrated to be accessible for early network
participants, while still being sufficiently large to present a meaningful
punishment if it is slashed for a misbehaving node. To understand the driving
considerations of the minimum stake value and the intended punishments, we need
to look at the probabilities of various scenarios and their relationships to the
staking values.

To this end, let us refer to the minimum staking amount as `M`, the number of
members in a group as `g`, and the number of groups in the relay as `G`. The
cost `o` of "owning" one single group, meaning the cost of being able to predict
or control its output or key generation and therefore its results, is `t x M`.
`t` here is the threshold, `g / 2 - 1`, and `g` is the number of members in a
group. Owning one group is not necessarily sufficient to be in control of
anything, since the relay is designed to make the next group unpredictable until
it is time to compute the next random number. Additionally, just controlling `t`
stakers is not enough to control a group, since new groups are formed from a
random selection of available stakers.

.Variables
[table,header,cols=2,sidebar]
|=========
| Variable | Meaning
| `c`      | Number of stakers in the network
| `g`      | Number of stakers in a single group
| `G`      | Number of groups in the threshold relay
| `s`      | Minimum stake amount (in KEEP)
|=========

.Derived Variables
[table,header,cols=3]
|=========
| Variable | Defined Value | Meaning
| `t`      | `g / 2 - 1`   | Number of stakers needed to control a single group
| `o`      | `t x M`       | Amount at stake if one entity owns a single group
|=========

From this information, we can start deriving the probabilities that any given
scenario may occur. The probabilities we're most interested in are in the
following table:

.System Probabilities
[table,header,cols=2]
|=========
| Aspect | Probability

| A given staker being chosen for a new group
| `1 / c`

| `t` specific stakers being chosen for a new group
| `(1 / c)^t`
// ``

| `t` specific stakers being chosen for a new group over `N` new groups
| `(1 / c)^t x N`
// ``

| A given group being chosen to create the next relay entry
| `1 / G`

| An entity controlling `d` stakers having a group they control over `N` new groups
| `(d / c)^t x N`
// ``

| An entity controlling `d` stakers having their group chosen to create the next
  relay entry
| `((d / c)^t x N) / G`
// `` Check me plz
|=========

=== Punishments

When designing incentives, we have to consider the distinction between wilfful
misbehavior and accidental misbehavior. In particular, the system should be
structured so as to tolerate some amount of network jitter for a given node,
while not allowing for a group to fail to produce a signature when it is
requested. The key observation here is that what matters is that the network be
able to respond to any request for a random number in a timely fashion. This
means, given the threshold nature of the signature mechanism, that we must
ensure at least half of a given group's nodes are available at any given moment.

Moreover, we must ensure that freeloaders are penalized. This means that a node
should not be capable of joining a relay group and then never do the work to
sign a request.

 - Mitigations to attacks based on incentives
 - Cost of owning a group
 - Cost of owning a majority of groups

== Upgrade Management

- Upgrading nodes
- Upgrading relay configuration
- Upgrading relay contracts
- Upgrade coordination/process

== System Details

The minimum stake required for participation in the relay is configured on
chain, and can be discovered by querying the `KeepRelayBeacon` contract for the
`minimumStake()`. Changes to the minimum stake are broadcast as
`MinimumStakeChanged(uint256 old, uint256 new)` events from the same contract.
 The frequency with which the minimum stake will be updated is currently
 unspecified but is expected to be low.

- DKG process + messages exchanged (specific format in an appendix?)
- Threshold signature process + messages exchanged (specific format in an appendix?)
- On-chain call structure (appendix?)
- On-chain event structure (appendix?)

== Anticipated Updates

- Tweaking incentives based on real-world observations
- Community governance of relay contracts and configuration

== Acknowledgements

- Dfinity
- Advisors