:toc: macro

= The Keep Random Beacon: An Implementation of a Threshold Relay

toc::[]

[abstract]
.Abstract
--
The Keep Network requires a trusted source of randomness for the process of Keep
selection. While the network requires that randomness to function correctly, the
source of randomness is itself broadly applicable. This trusted source of
randomness takes the form of a BLS Threshold Relay. We discuss implementation of
this random beacon, including assumptions and mitigations for bad actors and
poor network connectivity.
--


== Overview

 - Goals
 - Organization (core tech, state flow, incentives, ...)
 - Assumptions
 - High-level description

The threshold relay described in this paper is a way of generating verifiable
randomness that is resistant to bad players both in the relay network and on the
anchoring blockchain, assumed here to be Ethereum. The basic functioning of the
relay (further details are in the section on <<System Details>>) is:

 - Some number of groups exist in the relay.
 - An arbitrary seed value `v_s` counts as the first entry in the relay.footnote:[The
   importance, from a security perspective, of the seed value goes away almost
   immediately in a functioning network.]
 - A request `r_i` is dispatched to the chain for a new entry.
 - Information about the request is combined with the previous entry to produce
   a new relay entry seed value `v_r`.
 - `v_r` is used to choose a group to produce the response to the request.
 - `v_r` is signed by at least a subset of the chosen group members, and the
   resulting signature is the entry generated in response to the request. It is
   published to the anchoring blockchain as the entry `v_i`.

The following sections will detail how this basic function is implemented in
practice, including notes on <<Prior Work>> that motivated this design,
the <<Incentive Structures>> used to economically incentivize good behavior by
network participants, <<Core Technologies>> used in the network, and finally the
<<System Details>> that outline the implementation itself. <<Upgrade Management>>
is also discussed, along with <<Anticipated Updates>> to the network in the near
term.

.Keep Threshold Relay
image::img/generated/relay-diagram.png[Diagram of the Keep threshold relay]

== Prior Work

Dfinity has described their implementation of a random beacon backed by a
threshold relay in their consensus whitepaper
footnote:[https://dfinity.org/pdf-viewer/library/dfinity-consensus.pdf]. The
relay described in this paper is heavily based on the one devised by the Dfinity
team, with certain adjustments for implementation on an existing blockchain. The
key distinction between the Dfinity implementation and the Keep implementation
is that Keep has to contend with blockchains that do not implement the same
primitives as the in-house Dfinity chain targeted in their paper. Concerns such
as transaction costs and payment for beacon entries are therefore a core part of
the incentive system built around the Keep random beacon.

As described in the above paper, at the heart of the relay beacon is the
signature scheme described by Dan Boneh, Ben Lynn, and Hovav Shacham in
footnote:[D. Boneh, B. Lynn and H. Shacham, “Short signatures from the Weil
pairing”, Advances in Cryptology – ASIACRYPT 2001, Lecture Notes in Computer
Science, 2248 (2001), 514–532. Full version: Journal of Cryptology, 17 (2004),
297–319.], termed BLS. Three properties of the scheme are of particular use in
this case: BLS signatures can be used in _threshold_ mode, where _k_ of _n_
participants are sufficient to produce a combined signature; BLS threshold
signatures produce the same final signature irrespective of the participants;
and BLS signatures are typically shorter than those of many other threshold
signature schemes.

Finally, underpinning the process of generating new groups for BLS threshold
signatures in the system is a distributed key generation algorithm based on work
by Gennaro, Jarecki, Krawczyk, and Rabin footnote:[R. Gennaro, S. Jarecki, H.
Krawczyk, and T. Rabin. Advances in Cryptology — EUROCRYPT ’99: International
Conference on the Theory and Application of Cryptographic Techniques Prague,
Czech Republic, May 2–6, 1999 Proceedings, chapter Secure Distributed Key
Generation for Discrete-Log Based Cryptosystems, pages 295–310. Springer Berlin
Heidelberg, Berlin, Heidelberg, 1999 ;
http://groups.csail.mit.edu/cis/pubs/stasio/vss.ps.gz], as also described in the
Dfinity paper above. The Keep relay beacon publishes group public keys to the
anchoring blockchain and does member selection on-chain, but key generation
occurs between nodes.

== Core Technologies

=== Dependency Management?

- Repo pinning
- Commit-hash-based dependencies

=== Networking

- libp2p
- multiaddr
- floodsub?

=== Messaging

- protobuf
- sig/encryption libs for messages

=== Ethereum

- JSON-RPC

=== BLS Implementation

- bn
- go-dfinity-crypto

== System States

 - State diagrams
 - Details of node state, system state, chain state

== Mechanical Attack Mitigations

The Keep threshold relay is designed to mitigate as many instances of malicious
behavior as possible, as well as to encourage stakers to employ well-networked
and highly available systems for their clients. This is done in two parts:
choosing robust technical implementations (like threshold signatures) that are
resilient to high degrees of misbehavior and network failure, and calibrating
the incentive structure to ensure strong punishments for malicious actions. We
discuss several potential attacks that are mitigated via adjustments to the
mechanics of the system here.

=== Miner, Requestor, and Relay Influence

Let us remember that the most basic construction (discussed in the <<Overview>>)
of a request-based threshold relay uses the previous value mod the number of
active groups to determine the next group. This next group then signs the
previous value to produce the next value. This happens every time a relay entry
(that is, a random number) is requested. There are a few key problems that
manifest in this simple construction:

 - The relay can collude to know random numbers an infinite number of steps
   ahead of the requests.
 - Miners who have compromised a group can collude to censor a request until the
   previous entry would select a group they control.
 - Miners who have compromised a group can collude to censor a request that
   would select the group they control if they know the outcome would not be to
   their advantage.
 - A requestor who has compromised a group can wait to put a request in until
   the previous entry would select a group they control.
 - A requestor who has comporomised a group can wait to put a request in if it
   would select the group they control and the outcome would not be to their
   advantage.

We address each of these below. We assume here that controlling one group is
expensive, and controlling all groups is prohibitively so; see the section on
<<Incentives>> for more on what that requires.

==== Relay Frontrunning

One of the disadvantages of the simple construction above is that future entries
can be computed in advance of their use. For example, if it were known that a
lottery was being held in _N_ blocks, the relay could collude to run ahead that
number of entries so as to have the relay's value before the entry came due. The
Keep implementation of the relay mitigates this by using information about the
request to adjust the previous entry before signing it. In particular, the relay
provides the requestor the ability to specify a _seed_, which is XORed with the
previous entry to allow the requestor to add entropy to the final result.

NOTE: The seed itself must be unpredictable to the relay, or the relay could
still frontrun with the above mitigation; however, the mitigation for miner
censorship below further limits the ability to frontrun.

==== Miner Censorship

Miners can choose not to include a transaction that does not benefit them. For
example, if a given relay request comes in for a lottery the miner is also
participating in, and the group that will be selected is not under their
control, or the group _is_ under their control and they can determine the next
entry would not be favorable to them, the miner could censor the transaction
and effectively get a second chance at winning the lottery. The Keep
implementation of the relay mitigates this by using information from the block
to affect the choice of the group.

A simple implementation here could use the block hash of the request block XORed
with the previous entry, then mod against the number of groups to change the
result. However, miners have some control over block hashes as well. Instead,
the Keep relay waits 2 blocks after the request is seen, and uses these two
block hashes to decide the group. This elevates the requirement to having miners
frontrun by at least 2 blocks before being able to decide to censor a request.

==== Requestor Cheating

The last player in the set of actors involved in a relay interaction is the
requestor. The requestor is given the ability to add entropy to their request by
providing a seed to make the signing value less predictable. However, this also
gives the requestor the potential to influence the final outcome.

So why go forward 2 blocks for group selection instead of looking at a previous
block? If the group selection were based on a prior block, a requestor would
always be able to know which group their request would go to. Since the
requestor specifies a seed that influences the value signed by the selected
group, the requestor could wait to submit a request until they knew the signing
group would be the group the requestor controls. Thus, by mixing in the miner
censorship mitigation, which makes the signing group unpredictable until after
the request is made, we also reduce the requestor's ability to know who the
signing group will be at request time.

=== Denial of Service

Denial of service attacks are a problem in two phases of the relay's operation:
group formation and relay response generation. The relay itself can also be
DoSed by too many requests. The first two in particular share the requirement
that either a player outside or inside the relay be able to know enough about
the clients in a group to launch DoS attacks against them.

 - DoS of the signing group
 - DoS during group creation
 - DoS of the relay

== Incentives

 - Mitigations to attacks based on incentives
 - Cost of owning a group
 - Cost of owning a majority of groups

== Upgrade Management

- Upgrading nodes
- Upgrading relay configuration
- Upgrading relay contracts
- Upgrade coordination/process

== System Details

- DKG process + messages exchanged (specific format in an appendix?)
- Threshold signature process + messages exchanged (specific format in an appendix?)
- On-chain call structure (appendix?)
- On-chain event structure (appendix?)

== Anticipated Updates

- Tweaking incentives based on real-world observations
- Community governance of relay contracts and configuration

== Acknowledgements

- Dfinity
- Advisors