:toc: macro

= Trapdoor Commitments

toc::[]

A trapdoor commitment scheme allows a sender to commit to a message with 
information-theoretic privacy. i.e., given the transcript of the commitment
phase, the receiver, even with infinite computing power, cannot guess the 
committed message better than at random. On the other hand, when it comes to
opening the message, the sender is only computionally bound to the committed
message. 

Let's say the message is "Hello" and for whatever reason, it should be kept 
private. However, we want to prove we have decided on that message and that 
we have it "in mind". We can just publish a hash of that message as a proof.
Whenever we want, we can reveal the "Hello" message and prove we had decided
on that message in the past when the hash was published. 

The trapdoor scheme is indistinguishable from randomness and it means it is
resistant to brute force attacks. It uses the "trapdoor" value that the 
committing party can send a verifier to make the verification possible.
We send a commitment to verifier, that can happen at any time, and in future, 
we send a "trapdoor" value that lets to verify the commitment. 

In the first approach, the only thing needed for verification is the plaintext 
and commitment. In trapdoor scheme we need the plaintext, commitment and trapdoor. 
Trapdoor scheme separates what we are committing to and the key allowing for 
a verification of the commitment.

Another interesting property of trapdoor schemes is that knowledge of trapdoor 
allows to open a message in any possible way. 

Using an analogy of lockable boxes, commitment scheme can be described as 
locking the message in a steel box and passing it to receiver. A trapdoor 
commitment is a box with a tiny secret door. If someone knows the secret door, 
then this person is still able to change the committed message in the box, even 
after the commitment phase. 

== Pedersen commitment

We generate an order `q` cyclic group. To do this, we find a large Sophie 
Germain prime and use that as `q`. `p`, the modulus, is set to `2q+1`.

The order `q` subgroup of quadratic residues is cyclic and of prime order 
and every element in it is a generator. To get a generator of this subgroup, 
we choose any element `Z^p` and then square it, thus, ensuring that we have an 
element in the order `q` subgroup.

```
q <- Sophie Germain prime
p = 2q + 1

g = (randomFromZn[0, 2^p - 1]) ^2
h = (randomFromZn[0, 2^p - 1]) ^2
```

=== Generating commitment
`INPUT: secret`

```
r = randomFromZn[0, 2^q - 1]
digest = sha256(secret) % q

commitment = [ (g ^  digest) % p ] * [ (h ^ r) % p ]

return (commitment, r)
```

=== Commitment verification
`INPUT: secret, commitment, r`

```
digest = sha256(secret) % q

expectedCommitment  = [ (g ^ digest) % p ] * [ (h ^ r) % p ]

return commitment == expectedCommitment
```

If `g` and `h` are computed and distributed by a trusted third party such that
the discrete logarithm between `g` and `h` is unkown, we obtain unconditionally
hiding commitments. That is, even an unbounded adversary not knowing `g` and `h` 
will not be able to figure out plaintext message.

Sender knowing `g` and `h` can change the message he committed to
even after commitment has been published (but before `r` has been published) 
since it's possible to find another pair of `(r', secret')` evaluating to the 
same commitment. 

If `g` and `h` are publicly known, we obtain computional hiding and an unbounded 
adversary can simply try all possible `r` and `secret` till they evalute to the 
expected commitment.

== Elliptic Curve VSS

Traditional Pedersen algorithm, as described before, is based on large primes 
`p` and `q` and setting `G` to be the subgroup of `Z^p` of order `q`. 
In this case the multiplication operation in `G` is multiplication modulo `p`. 

When we want to work with EC-based encryption (and this is the case for 
e.g. EC-DSA), we need to adjust the protocol. This is obtained by choosing `G` 
as a group of points on an elliptic curve of cardinality `q`. In this case the 
multiplication operation in `G` is the group operation over the curve. 
`g` is the randomly selected point on the curve.

Curve described by `G` and `q` as well as `g` can be public parameters for 
a computional binding scheme.

=== Generating commitment
`INPUT: secret`

```
pkey = (randomFromZn[0, q - 1])
r = (randomFromZn[0, q - 1])

digest = sha256(secret) mod q

// + and * are operations on the selected curve
he = h + g * pkey
commitment = g * digest + he * r

return (r, pkey, commitment)
```

=== Commitment verification
`INPUT: secret, r, pkey, commitment`

```
digest = sha256(secret) mod q

// + and * are operations on the selected curve
a = g * r 
b = h + g * pkey 
c = commitment + g * (-digest) 

pairing(a, b) == pairing(g, c)
```


References

* Gennaro R., Goldfeder S., Narayanan A. (2016) Threshold-Optimal DSA/ECDSA 
Signatures and an Application to Bitcoin Wallet Security. In: Manulis M., 
Sadeghi AR., Schneider S. (eds) Applied Cryptography and Network Security. 
ACNS 2016. Lecture Notes in Computer Science, vol 9696. Springer, Cham

* Pedersen T.P. (1992) Non-Interactive and Information-Theoretic Secure 
Verifiable Secret Sharing. In: Feigenbaum J. (eds) Advances in 
Cryptology — CRYPTO ’91. CRYPTO 1991. Lecture Notes in Computer Science, 
vol 576. Springer, Berlin, Heidelberg

* Vitalik Buterin, Exploring Elliptic Curve Pairings 
https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627