:toc: macro
:toclevels: 4

= T-ECDSA Protocol

toc::[]

== Phases Description

=== Setup

==== Commitment Master Public Key
[.lead]
_Commitment Master Public Key_ is a value needed for commitment generation.
This setup needs to be performed before each of two phases: key generation and signing.

Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers.
After receiving all shares signers combine them to get _Commitment Master Public Key_.

A _Commitment Master Public Key Share_ is a point in an abstract cyclic group _G2_ 
of link:https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256/cloudflare[256-bit Barreto-Naehrig]
curve.

Output::
* _Commitment Master Public Key_

=== Key Generation

[.lead]
In this phase signers jointly generate _ECDSA Key_ which is used in the Signing
phase.

Each signer generates _Secret Key Share_ and _Public Key Share_ which together form
_ECDSA Key Share_. +
Since _Secret Key Share_ must always be kept private, signer encrypts it with 
Paillier and publishes the encrypted _Secret Key Share_ along with plaintext 
_Public Key Share_ to other signers. +
After receiving all shares, signers combine them to get _ECDSA Key_, consisting of
_Encrypted Secret Key_ and _Public Key_. _Secret Key_ is encrypted with threshold
Paillier scheme in a way that no single signer is able decrypt it.

This phase requires all signers in the group to cooperate to produce a valid 
_ECDSA Key_. +
If a malicious behavior is detected from any signer, the whole phase is aborted.

Input::
* _Commitment Master Public Key_

Output::
* _ECDSA Key_ {_Encrypted Secret Key_, _Public Key_}

=== Signing

[.lead]
In this phase signers jointly generate a _Signature_ for a _Message Hash_.

Signers communicate with each other in 6 rounds, exchanging information
to produce a T-ECDSA _Signature_ in a {_R_, _S_} format over a _Message Hash_ 
which is expected to be exactly 32 bytes.

Before starting this phase a fresh _Commitment Master Public Key_ should be generated.

This phase requires also _ECDSA Key_ which is a result of Key Generation Phase.

To complete this round, just part of signers is required. The minimum number of signers
needed is specified by _Threshold_. +
Signer can be expelled from the signing group if he misbehaves or doesn't provide
a message on time.

Input::
* _Commitment Master Public Key_
* _ECDSA Key_
* _Message Hash_

Output::
* _Signature_ {_R_, _S_}

== Rounds Description

=== Setup

==== Master Public Key

Output::
* _Commitment Master Public Key_

//-

. Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers in _CommitmentMasterPublicKeyShareMessage_.
+
.MasterPublicKeyShareMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`masterPublicKeyShare` 
^|`[]byte`
^|Master Public Key Share
|=== 

. Each signer combines all _Commitment Master Public Key Shares_ to get 
_Commitment Master Public Key_.

=== Key Generation

==== Round #1

Input::
* _Commitment Master Public Key_

Output::
* _Public Key Share Commitment_

//-

. Each signer generates _ECDSA Key Share_ which consists of _Secret Key Share_ and
_Public Key Share_.
+
_Secret Key Share_ value must be kept secret and never shared in a plaintext form.
+
_Public Key Share_ value cannot be exposed until all signers in the group commit
to their values.

. Each signer calculates a commitment to the _Public Key Share_ value and 
publishes this commitment in  _PublicKeyShareCommitmentMessage_.

.PublicKeyShareCommitmentMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`publicKeyShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _Public Key Share_
|=== 

==== Round #2

Input::
* _Public Key Share Commitment_

Output::
* _ECDSA Key_ {_Encrypted Secret Key_, _Public Key_}

//-

After commitments from all signers are gathered the second round starts.

. Signers reveal their _ECDSA Key Shares_ and send _KeyShareRevealMessage_. 
+
Since _Secret Key Share_ should always be kept secret it is first encrypted with
Paillier and this encrypted value is published along with Zero Knowledge Proof 
Π~i~ to confirm that _Secret Key Share_ value is in [-q^3^, q^3^] range.
+
_Public Key Share_ is published with a decommitment key used in a previous round
to produce commitment to _Public Key Share_ value.
+
.KeyShareRevealMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyShare` 
^|`paillier.Cypher`
^|Encrypted _Secret Key Share_

^|`publicKeyShare` 
^|`curve.Point`
^|_Public Key Share_

^|`publicKeyShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for _Public Key Share_

^|`secretKeyProof` 
^|`zkp.DsaPaillierKeyRangeProof`
^|ZKP Π~i~ -- _Secret Key Share_ is in range [-q^3^, q^3^]
|=== 

. Each signer validates received _KeyShareRevealMessages_ and combines shares 
to get encrypted _Secret Key_ and _Public Key_ which together forms _ECDSA Key_.

=== Signing

==== Round #1 [[sign_round_1]]

Input::
* _Encrypted Secret Key_
* _Commitment Master Public Key_

Output::
* _Secret Key Factor Share Commitment_

//-

. Each signer generates _Encrypted Secret Key Factor Share_ and _Secret Key Multiple Share_. 
These values are kept private for now. +

. Signer calculates a commitment to both values and publishes the commitment in 
_SignRound1Message_.
+
.SignRound1Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _Secret Key Factor Share_ and _Secret Key Multiple Share_
|=== 

==== Round #2 [[sign_round_2]]

Output::
* _Encrypted Secret Key Factor Share_
* _Secret Key Multiple Share_
* Decommitment key for _Secret Key Factor Share Commitment_
* _Zero Knowledge Proof Π~1,i~_

//-

. Each signer calculates a Zero Knowledge Proof Π~1,i~ for his individual parameters.

. Signers publish _SignRound2Message_ containing _Secret Key Factor Share_, 
_Secret Key Multiple Share_ and decommitment key for the commitment from <<sign_round_1>>.
+
.SignRound2Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyFactorShare` 
^|`paillier.Cypher`
^|_Secret Key Factor Share_

^|`secretKeyMultipleShare` 
^|`paillier.Cypher`
^|_Secret Key Multiple Share_

^|`secretKeyFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment to _Secret Key Factor Share_ and _Secret Key Multiple Share_

^|`secretKeyFactorProof` 
^|`zkp.DsaPaillierSecretKeyFactorRangeProof`
^|ZKP Π~1,i~
|=== 

. Signer validates received _SignRound1Messages_ and _SignRound2Messages_. +
Combines shares to get _Secret Key Factor_ and _Secret Key Multiple_.

==== Round #3 [[sign_round_3]]

Input::
* _Secret Key Factor_
* _Secret Key Multiple_
* _Commitment Master Public Key_

Output::
* _Signature Factor Share Commitment_

//-

. Each signer computes a set of parameters and calculates a commitment to these
values. All the parameters are kept private for now.

. Signer publishes the commitment in a _SignRound3Message_.
+
.SignRound3Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to parameters from <<sign_round_3>>
|=== 

==== Round #4 [[sign_round_4]]

Output::
* _Signature Factor Public Share_
* _Signature Unmask Share_
* Decommitment key for _Signature Factor Share Commitment_
* _Zero Knowledge Proof Π~2,i~_

//-

This round starts after all signers share their commitments in <<sign_round_3>>.

. Each signer calculates a Zero Knowledge Proof Π~2,i~ for his individual parameters.

. Signers publish _SignRound4Message_ containing the Zero Knowledge Proof Π~2,i~,
along with parameters and decommitment key from the <<sign_round_3>>.
+
.SignRound4Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureFactorPublicShare` 
^|`curve.Point`
^|_Signature Factor Public Share_

^|`signatureUnmaskShare` 
^|`paillier.Cypher`
^|_Encrypted Signature Unmask Share_

^|`signatureFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment from <<sign_round_3>>

^|`signatureFactorProof` 
^|`zkp.EcdsaSignatureFactorRangeProof`
^|ZKP Π~2,i~
|=== 

. Signer validates received _SignRound3Messages_ and _SignRound4Messages_. +
Combines shares to get _Signature Factor Public_ and _Encrypted Signature Unmask_.

==== Round #5 [[sign_round_5]]

Input::
* _Signature Factor Public_
* _Encrypted Signature Unmask_

Output::
* _Signature Unmask Partial Decryption_

//-

. Each signer computes hash of _Signature Factor Public_ parameter.

. Signers jointly decrypt _Encrypted Signature Unmask_ with Paillier, so each signer
receives just a part of _Signature Unmask_.

. Signer publishes _SignRound5Message_.
+
.SignRound5Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureUnmaskPartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature Unmask_ partial decryption.
|=== 

. Signer validates received _SignRound5Messages_. +
Combines partial decryptions to get _Signature Unmask_.

==== Round #6 [[sign_round_6]]

Input::
* _Signature Unmask_
* _Message Hash_

Output::
* _Signature Partial Decryption_

//-

. Each signer computes _Encrypted Signature_ value which next they jointly decrypt.
Each signer receives a part of _Signature_.

. Signer publishes _SignRound6Message_.
+
.SignRound6Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signaturePartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature.S_ partial decryption.
|=== 

. Signer validates received _SignRound6Messages_. +
Combines partial decryptions to get _Signature_.

. Signer produces a _T-ECDSA Signature_ in {R,S} format where:
[horizontal]
R:: Hash of _Signature Factor Public_
S:: _Signature_
