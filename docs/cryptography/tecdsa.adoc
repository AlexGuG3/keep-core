:toc: macro
:toclevels: 4

= T-ECDSA Protocol

toc::[]

== Phases Description

=== Setup

==== Commitment Master Public Key
[.lead]
_Commitment Master Public Key_ is a value needed for commitment generation.
It is generated individually for each signer. This setup needs to be performed 
before each of two phases: key generation and signing.

Each signer generates _Commitment Master Public Key Share_ and broadcasts it to other signers.
After receiving all shares signers combine them to get _Commitment Master Public Key_.

A _Commitment Master Public Key Share_ is a point in an abstract cyclic group _G2_ of link:https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256/cloudflare[256-bit Barreto-Naehrig]
curve.

Output::
* _Commitment Master Public Key_

=== Key Generation

[.lead]
In this phase signers jointly generate _DSA Key_ which will be used in the Signing
phase.

Each signer generates _Secret Key Share_ and _Public Key Share_ which form
_ECDSA Key Share_. +
Since _Secret Key Share_ must always be kept private, signer encrypts it with 
Paillier and broadcasts the encrypted _Secret Key Share_ along with _Public Key Share_
to other signers. +
After receiving all shares, signers combine them to get _ECDSA Key_, consisting of
_Encrypted Secret Key_ and _Public Key_.

This phase requires all signers in the group to produce a valid _ECDSA Key_.

Input::
* _Commitment Master Public Key_

Output::
* _ECDSA Key_ {_Encrypted Secret Key_, _Public Key_}

=== Signing

[.lead]
In this phase signers jointly generate a _Signature_ for a _Message Hash_.

Signers communicate with each other in 6 rounds, exchanging information
to produce a T-ECDSA _Signature_ in a {_R_, _S_} format over a _Message Hash_ 
which is expected to be exactly 32 bytes.

Before starting this phase a fresh _Commitment Master Public Key_ should be generated.

This phase requires also _ECDSA Key_ which is a result of Key Generation Phase.

To complete this round just part of signers is required. The number of signers
needed is specified by _Threshold_.  +
Signer can be expelled from the signing group if he misbehaves or doesn't provide
a message on time.

Input::
* _Commitment Master Public Key_
* _ECDSA Key_
* _Message Hash_

Output::
* _Signature_ {_R_, _S_}

== Rounds Description

=== Setup

==== Master Public Key

Output::
* _Commitment Master Public Key_

//-

. Each signer generates _Commitment Master Public Key Share_ and broadcasts it to other signers
 in _Commitment Master Public Key Share Message_.
+
.Master Public Key Share Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`masterPublicKeyShare` 
^|`[]byte`
^|Master Public Key Share
|=== 

. Each signer combines all __Commitment Master Public Key Shares_ to get __Commitment Master Public Key_.

=== Key Generation

==== Round #1

Input::
* _Commitment Master Public Key_

Output::
* _Public Key Share Commitment_

//-

. Each signer generates _DSA Key Share_ which consists of _Secret Key Share_ and
_Public Key Share_.
+
_Secret Key Share_ value must be kept secret and never shared.
+
_Public Key Share_ value cannot be exposed until all signers in the group commit
to their values.

. Each signer calculates a commitment to the _Public Key Share_ value and 
broadcasts this commitment in  _Public Key Share Commitment Message_.

.Public Key Share Commitment Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`publicKeyShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _Public Key Share_
|=== 

==== Round #2

Input::
* _Public Key Share Commitment_

Output::
* _ECDSA Key_ {_Encrypted Secret Key_, _Public Key_}

//-

After commitments from all signers are gathered the second round starts.

. Signers reveal their _DSA Key Shares_ and broadcast _Key Share Reveal Message_. 
+
Since _Secret Key Share_ should always be kept secret it is first encrypted with
Paillier and this encrypted value is broadcasted along with Zero Knowledge Proof 
Π~i~ to confirm that _Secret Key Share_ value is in [-q^3^, q^3^] range.
+
_Public Key Share_ is broadcasted with a decommitment key used in a previous round
to produce commitment to _Public Key Share_ value.
+
.Key Share Reveal Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyShare` 
^|`paillier.Cypher`
^|Encrypted _Secret Key Share_

^|`publicKeyShare` 
^|`curve.Point`
^|_Public Key Share_

^|`publicKeyShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for _Public Key Share_

^|`secretKeyProof` 
^|`zkp.DsaPaillierKeyRangeProof`
^|ZKP Π~i~ -- _Secret Key Share_ is in range [-q^3^, q^3^]
|=== 

. Each signer validates received _Key Share Reveal Messages_ and combines shares 
to get encrypted _Secret Key_ and _Public Key_ which together forms _DSA Key_.

=== Signing

==== Round #1 [[sign_round_1]]

Input::
* _Encrypted Secret Key_
* _Commitment Master Public Key_

Output::
* _Secret Key Factor Share Commitment_

//-

. Each signer generates _Encrypted Secret Key Factor Share_ and _Secret Key Multiple Share_. These
values are kept private for now. +

. Signer calculates a commitment to both values and broadcasts the commitment in _Sign Round 1 Message_.
+
.Sign Round 1 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _Secret Key Factor Share_ and _Secret Key Multiple Share_
|=== 

==== Round #2 [[sign_round_2]]

Output::
* _Encrypted Secret Key Factor Share_
* _Secret Key Multiple Share_
* Decommitment key for _Secret Key Factor Share Commitment_
* _Zero Knowledge Proof Π~1,i~_

//-

. Each signer calculates a Zero Knowledge Proof Π~1,i~ for his individual parameters.

. Signers broadcast _Sign Round 2 Message_ containing _Secret Key Factor Share_, 
_Secret Key Multiple Share_ and decommitment key for the commitment from <<sign_round_1>>.
+
.Sign Round 2 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`secretKeyFactorShare` 
^|`paillier.Cypher`
^|_Secret Key Factor Share_

^|`secretKeyMultipleShare` 
^|`paillier.Cypher`
^|_Secret Key Multiple Share_

^|`secretKeyFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment to _Secret Key Factor Share_ and _Secret Key Multiple Share_

^|`secretKeyFactorProof` 
^|`zkp.DsaPaillierSecretKeyFactorRangeProof`
^|ZKP Π~1,i~
|=== 

. Signer validates received _Sign Round 1 Messages_ and _Sign Round 2 Messages_. +
Combines shares to get _Secret Key Factor_ and _Secret Key Multiple_.

==== Round #3 [[sign_round_3]]

Input::
* _Secret Key Factor_
* _Secret Key Multiple_
* _Commitment Master Public Key_

Output::
* _Signature Factor Share Commitment_

//-

. Each signer computes a set of parameters and calculates a commitment to these
values. All the parameters are kept private for now.

. Signer broadcasts the commitment in a _Sign Round 3 Message_.
+
.Sign Round 3 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to parameters from <<sign_round_3>>
|=== 

==== Round #4 [[sign_round_4]]

Output::
* _Signature Factor Public Share_
* _Signature Unmask Share_
* Decommitment key for _Signature Factor Share Commitment_
* _Zero Knowledge Proof Π~2,i~_

//-

This round starts after all signers share their commitments in <<sign_round_3>>.

. Each signer calculates a Zero Knowledge Proof Π~2,i~ for his individual parameters.

. Signers broadcast _Sign Round 4 Message_ containing the Zero Knowledge Proof Π~2,i~,
along with parameters and decommitment key from the <<sign_round_3>>.
+
.Sign Round 4 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureFactorPublicShare` 
^|`curve.Point`
^|_Signature Factor Public Share_

^|`signatureUnmaskShare` 
^|`paillier.Cypher`
^|_Encrypted Signature Unmask Share_

^|`signatureFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment from <<sign_round_3>>

^|`signatureFactorProof` 
^|`zkp.EcdsaSignatureFactorRangeProof`
^|ZKP Π~2,i~
|=== 

. Signer validates received _Sign Round 3 Messages_ and _Sign Round 4 Messages_. +
Combines shares to get _Signature Factor Public_ and _Encrypted Signature Unmask_.

==== Round #5 [[sign_round_5]]

Input::
* _Signature Factor Public_
* _Encrypted Signature Unmask_

Output::
* _Signature Unmask Partial Decryption_

//-

. Each signer computes hash of _Signature Factor Public_ parameter.

. Signers jointly decrypt _Encrypted Signature Unmask_ with Paillier, so each signer
receives just a part of _Signature Unmask_.

. Signer broadcasts _Sign Round 5 Message_.
+
.Sign Round 5 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signatureUnmaskPartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature Unmask_ partial decryption.
|=== 

. Signer validates received _Sign Round 5 Messages_. +
Combines partial decryptions to get _Signature Unmask_.

==== Round #6 [[sign_round_6]]

Input::
* _Signature Unmask_
* _Message Hash_

Output::
* _Signature Partial Decryption_

//-

. Each signer computes _Encrypted Signature_ value which next they jointly decrypt.
Each signer receives a part of _Signature_.

. Signer broadcasts _Sign Round 6 Message_.
+
.Sign Round 6 Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signerID` 
^|`string`
^|Signer's ID

^|`signaturePartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature.S_ partial decryption.
|=== 

. Signer validates received _Sign Round 6 Messages_. +
Combines partial decryptions to get _Signature_.

. Signer produces a _T-ECDSA Signature_ in {R,S} format where:
[horizontal]
R:: Hash of _Signature Factor Public_
S:: _Signature_
