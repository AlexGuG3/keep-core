:toc: macro
:toclevels: 4

= T-ECDSA Protocol

toc::[]

== Phases Description

=== Setup

==== Commitment Master Public Key
[.lead]
_Commitment Master Public Key_ is a value needed for commitment generation.
This setup needs to be performed before each of two phases: key generation and signing.

Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers.
After receiving all shares signers combine them to get _Commitment Master Public Key_.

A _Commitment Master Public Key Share_ is a point in an abstract cyclic group _G2_ 
of link:https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256/cloudflare[256-bit Barreto-Naehrig]
curve.

Output::
* _Commitment Master Public Key_

=== Key Generation

[.lead]
In this phase signers jointly generate an _ECDSA Key_ which is used in the Signing
phase.

Each signer generates an _ECDSA Private Key Share_ and an _ECDSA Public Key Share_ 
which together form an _ECDSA Key Share_. +
Since the _ECDSA Private Key Share_ must always be kept private, signer encrypts 
it with Paillier and publishes the encrypted _ECDSA Private Key Share_ along with 
the plaintext _ECDSA Public Key Share_ to other signers. +
After receiving all shares, signers combine them to get the _ECDSA Key_, consisting 
of the _Encrypted ECDSA Private Key_ and the _ECDSA Public Key_. The _ECDSA Private Key_ 
is encrypted with threshold Paillier scheme in a way that no single signer is able 
to decrypt it.

This phase requires all signers in the group to cooperate to produce a valid 
_ECDSA Key_. +
If malicious behavior is detected from any signer, the whole phase is aborted.

Input::
* _Commitment Master Public Key_

Output::
* _ECDSA Key_ {_Encrypted ECDSA Private Key_, _ECDSA Public Key_}

=== Signing

[.lead]
In this phase the signers jointly generate a _Signature_ for a _Message Hash_.

Signers communicate with each other in 6 rounds, exchanging information
to produce a T-ECDSA _Signature_ in a {_R_, _S_} format over a _Message Hash_ 
which is expected to be exactly 32 bytes.

Before starting this phase a fresh _Commitment Master Public Key_ should be generated.

This phase requires also _ECDSA Key_ which is a result of Key Generation Phase.

To complete this phase, just part of signers is required. The minimum number of 
signers needed is specified by _Threshold_. +
A signer can be expelled from the signing group if they misbehave or don't provide
a message on time.

Input::
* _Commitment Master Public Key_
* _ECDSA Key_
* _Message Hash_

Output::
* _Signature_ {_R_, _S_}

== Rounds Description

=== Setup

==== Master Public Key

Output::
* _Commitment Master Public Key_

//-

. Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers in _CommitmentMasterPublicKeyShareMessage_.
+
.MasterPublicKeyShareMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`masterPublicKeyShare` 
|`[]byte`
|Master Public Key Share
|=== 

. Each signer generates his own _Commitment Master Public Key_ and publishes it 
to other signers in _CommitmentMasterPublicKeyMessage_.

=== Key Generation

==== Round #1

Input::
* _Commitment Master Public Key_

Output::
* _Public Key Share Commitment_

//-

. Each signer generates _ECDSA Key Share_ which consists of _ECDSA Private Key Share_ 
and _ECDSA Public Key Share_.
+
_ECDSA Private Key Share_ value must be kept secret and never shared in a plaintext 
form.
+
_ECDSA Public Key Share_ value cannot be exposed until all signers in the group 
commit to their values.

. Each signer calculates a commitment to the _ECDSA Public Key Share_ value and 
publishes this commitment in  _PublicKeyShareCommitmentMessage_.

.PublicKeyShareCommitmentMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`publicKeyShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to _ECDSA Public Key Share_
|=== 

==== Round #2

Input::
* _ECDSA Public Key Share Commitment_

Output::
* _ECDSA Key_ {_Encrypted ECDSA Private Key_, _ECDSA Public Key_}

//-

After commitments from all signers are gathered the second round starts.

. Signers reveal their _ECDSA Key Shares_ and send _KeyShareRevealMessage_. 
+
Since _ECDSA Private Key Share_ should always be kept secret it is first encrypted with
Paillier and this encrypted value is published along with Zero Knowledge Proof 
Π~i~, which states that:
+
****
∃ _secretKeyShare_ ∈ [-q^3^, q^3^] such that

_g_^_secretKeyShare_^ = _publicKeyShare_

D(_encryptedSecretKeyShare_) = _secretKeyShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
****
+
_ECDSA Public Key Share_ is published with a decommitment key used in a previous 
round to produce a commitment to _ECDSA Public Key Share_ value.
+
.KeyShareRevealMessage
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyShare` 
|`paillier.Cypher`
|Encrypted _ECDSA Private Key Share_

|`publicKeyShare` 
|`curve.Point`
|_ECDSA Public Key Share_

|`publicKeyShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for _ECDSA Public Key Share_

|`secretKeyProof` 
|`zkp.DsaPaillierKeyRangeProof`
|ZKP Π~i~
|=== 

. Each signer validates received _KeyShareRevealMessages_ and combines shares 
to get encrypted _ECDSA Private Key_ and _ECDSA Public Key_ which together form 
_ECDSA Key_.

=== Signing

==== Round #1 [[sign_round_1]]

Input::
* _Encrypted ECDSA Private Key_
* _Commitment Master Public Key_

Output::
* _ECDSA Private Key Factor Share Commitment_

//-

. Each signer generates _Encrypted ECDSA Private Key Factor Share_ and 
_ECDSA Private Key Multiple Share_. These values are kept private for now. +

. Signer calculates a commitment to both values and publishes the commitment in 
_SignRound1Message_.
+
.SignRound1Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyFactorShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_
|=== 

==== Round #2 [[sign_round_2]]

Output::
* _Encrypted ECDSA Private Key Factor Share_
* _ECDSA Private Key Multiple Share_
* Decommitment key for _ECDSA Private Key Factor Share Commitment_
* _Zero Knowledge Proof Π~1,i~_

//-

. Each signer calculates a Zero Knowledge Proof Π~1,i~ for his individual parameters,
which states that:
+
****
∃ _secretKeyFactorShare_ ∈ [-q^3^, q^3^] such that

D(_encryptedSecretKeyFactorShare_) = _secretKeyFactorShare_

D(_secretKeyMultipleShare_) = _secretKeyFactorShare_ * D(_secretKey_)

where _q_ is an order of an Elliptic Curve and D is a Decrypt function of a Paillier scheme
****

. Signers publish _SignRound2Message_ containing _ECDSA Private Key Factor Share_, 
_ECDSA Private Key Multiple Share_ and decommitment key for the commitment from 
<<sign_round_1>>.
+
.SignRound2Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`secretKeyFactorShare` 
|`paillier.Cypher`
|_ECDSA Private Key Factor Share_

|`secretKeyMultipleShare` 
|`paillier.Cypher`
|_ECDSA Private Key Multiple Share_

|`secretKeyFactorShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for a commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_

|`secretKeyFactorProof` 
|`zkp.DsaPaillierSecretKeyFactorRangeProof`
|ZKP Π~1,i~
|=== 

. Signer validates received _SignRound1Messages_ and _SignRound2Messages_. +
Combines shares to get _ECDSA Private Key Factor_ and _ECDSA Private Key Multiple_.

==== Round #3 [[sign_round_3]]

Input::
* _ECDSA Private Key Factor_
* _ECDSA Private Key Multiple_
* _Commitment Master Public Key_

Output::
* _Signature Factor Share Commitment_

//-

. Each signer computes a set of parameters: _Signature Factor Public Share_, and 
_Signature Unmask Share_ and calculates a commitment to these
values. All the parameters are kept private for now, they will be used later to
compute the final signature.

. Signer publishes the commitment in a _SignRound3Message_.
+
.SignRound3Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureFactorShareCommitment` 
|`commitment.MultiTrapdoorCommitment`
|Commitment to parameters from <<sign_round_3>>
|=== 

==== Round #4 [[sign_round_4]]

Output::
* _Signature Factor Public Share_
* _Signature Unmask Share_
* Decommitment key for _Signature Factor Share Commitment_
* _Zero Knowledge Proof Π~2,i~_

//-

This round starts after all signers share their commitments in <<sign_round_3>>.

. Each signer calculates a Zero Knowledge Proof Π~2,i~ for his individual parameters,
which states that:
+
****
∃ _signatureFactorSecretShare_ ∈ [-q^3^, q^3^], _signatureFactorPublicShare_ ∈ [-q^8^, q^8^] such that

_g_^_signatureFactorSecretShare_^ = _signatureFactorPublicShare_

D(_signatureUnmaskShare_) = _signatureFactorSecretShare_ × D(_secretKeyFactor_) + _q_ × _signatureFactorMaskShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
****

. Signers publish _SignRound4Message_ containing the Zero Knowledge Proof Π~2,i~,
along with parameters and decommitment key from the <<sign_round_3>>.
+
.SignRound4Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureFactorPublicShare` 
|`curve.Point`
|_Signature Factor Public Share_

|`signatureUnmaskShare` 
|`paillier.Cypher`
|_Encrypted Signature Unmask Share_

|`signatureFactorShareDecommitmentKey` 
|`commitment.DecommitmentKey`
|Decommitment key for a commitment from <<sign_round_3>>

|`signatureFactorProof` 
|`zkp.EcdsaSignatureFactorRangeProof`
|ZKP Π~2,i~
|=== 

. Signer validates received _SignRound3Messages_ and _SignRound4Messages_. +
Combines shares to get _Signature Factor Public_ and _Encrypted Signature Unmask_.

==== Round #5 [[sign_round_5]]

Input::
* _Signature Factor Public_
* _Encrypted Signature Unmask_

Output::
* _Signature Unmask Partial Decryption_

//-

. Each signer computes a hash of _Signature Factor Public_ parameter.

. Signers jointly decrypt _Encrypted Signature Unmask_ with Paillier, so each signer
receives just a partial decryption of _Signature Unmask_.

. Signer publishes _SignRound5Message_.
+
.SignRound5Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signatureUnmaskPartialDecryption` 
|`paillier.PartialDecryption`
|_Signature Unmask_ partial decryption.
|=== 

. Signer validates received _SignRound5Messages_. +
Combines partial decryptions to get _Signature Unmask_.

==== Round #6 [[sign_round_6]]

Input::
* _Signature Unmask_
* _Message Hash_

Output::
* _Signature Partial Decryption_

//-

. Each signer computes _Encrypted Signature_ value for a _Message Hash_ with 
_Signature Unmask_, _Signature Factor Public Hash_ and encrypted _ECDSA Private Key Factor_ 
and _ECDSA Private Key Multiple_. +
It's possible to perform a computation on Paillier-encrypted parameters because 
it's an additively homomorphic scheme.

. Signers jointly decrypt the computed _Encrypted Signature_, so each signer receives 
a partial decryption of _Signature_.

. Signer publishes _SignRound6Message_.
+
.SignRound6Message
[%header]
|=== 
^|Field Name ^|Type ^|Description

|`signaturePartialDecryption` 
|`paillier.PartialDecryption`
|_Signature.S_ partial decryption.
|=== 

. Signer validates received _SignRound6Messages_ and combines partial decryptions 
to get _Signature_.

. Signer produces a _T-ECDSA Signature_ in {R,S} format where:
[horizontal]
R:: Hash of _Signature Factor Public_
S:: _Signature_

== Threats

* `Master Trapdoor` (`x`) is known to a committer. +
The security of a commitment depends solely on a verifier. `Master Trapdoor` 
generated in a setup phase has to remain secret. Committer cannot be able to evaluate
a value of `Master Trapdoor` in any way (e.g. by brute-forcing if the value is too weak). +
It's described in 
link:https://github.com/keep-network/keep-core/blob/master/docs/cryptography/tecdsa_setup.adoc#master-public-key[Master Public Key setup protocol] 
documentation.

* Signers provide too short `ECDSA Private Key Shares`. +
If the shares have small bit length, then a resulting `ECDSA Private Key` will be weak.
It gives an opportunity to brute-force the `ECDSA Private Key` when knowing 
`ECDSA Public Key`. +
Another scenario is that adversarial Signer provides a share which is close to 
curve's cardinality reduced by another signer's share. This way his share "clears"
the share of another participant. +
It's covered by an issue link:https://github.com/keep-network/keep-core/issues/270[#270]

* Adversary delivers invalid/corrupted partial decryption in round 5 or 6. +
The partial decryption may be corrupted. The decryption may also be valid, but underlying
value may not be evaluated from the previously published parameters. +
It's covered by an issue link:https://github.com/keep-network/keep-core/issues/246[#246]

* Signer provides invalid Commitment, Decommitment Key or Zero Knowledge Proof. +
In case of a misbehavior in Signing phase the signer is removed from the group 
and his shares are not taking a part in calculations anymore. When it happens in
Key Generation phase the protocol is aborted.
