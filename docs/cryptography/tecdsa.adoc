:toc: macro
:toclevels: 4

= T-ECDSA Protocol

toc::[]

== Phases Description

=== Setup

==== Commitment Master Public Key
[.lead]
_Commitment Master Public Key_ is a value needed for commitment generation.
This setup needs to be performed before each of two phases: key generation and signing.

Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers.
After receiving all shares signers combine them to get _Commitment Master Public Key_.

A _Commitment Master Public Key Share_ is a point in an abstract cyclic group _G2_ 
of link:https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256/cloudflare[256-bit Barreto-Naehrig]
curve.

Output::
* _Commitment Master Public Key_

=== Key Generation

[.lead]
In this phase signers jointly generate _ECDSA Key_ which is used in the Signing
phase.

Each signer generates _ECDSA Private Key Share_ and _ECDSA Public Key Share_ which 
together form _ECDSA Key Share_. +
Since _ECDSA Private Key Share_ must always be kept private, signer encrypts it with 
Paillier and publishes the encrypted _ECDSA Private Key Share_ along with plaintext 
_ECDSA Public Key Share_ to other signers. +
After receiving all shares, signers combine them to get _ECDSA Key_, consisting of
_Encrypted ECDSA Private Key_ and _ECDSA Public Key_. _ECDSA Private Key_ is encrypted 
with threshold Paillier scheme in a way that no single signer is able decrypt it.

This phase requires all signers in the group to cooperate to produce a valid 
_ECDSA Key_. +
If a malicious behavior is detected from any signer, the whole phase is aborted.

Input::
* _Commitment Master Public Key_

Output::
* _ECDSA Key_ {_Encrypted ECDSA Private Key_, _ECDSA Public Key_}

=== Signing

[.lead]
In this phase signers jointly generate a _Signature_ for a _Message Hash_.

Signers communicate with each other in 6 rounds, exchanging information
to produce a T-ECDSA _Signature_ in a {_R_, _S_} format over a _Message Hash_ 
which is expected to be exactly 32 bytes.

Before starting this phase a fresh _Commitment Master Public Key_ should be generated.

This phase requires also _ECDSA Key_ which is a result of Key Generation Phase.

To complete this phase, just part of signers is required. The minimum number of 
signers needed is specified by _Threshold_. +
Signer can be expelled from the signing group if he misbehaves or doesn't provide
a message on time.

Input::
* _Commitment Master Public Key_
* _ECDSA Key_
* _Message Hash_

Output::
* _Signature_ {_R_, _S_}

== Rounds Description

=== Setup

==== Master Public Key

Output::
* _Commitment Master Public Key_

//-

. Each signer generates _Commitment Master Public Key Share_ and publishes it to 
other signers in _CommitmentMasterPublicKeyShareMessage_.
+
.MasterPublicKeyShareMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`masterPublicKeyShare` 
^|`[]byte`
^|Master Public Key Share
|=== 

. Each signer combines all _Commitment Master Public Key Shares_ to get 
_Commitment Master Public Key_.

=== Key Generation

==== Round #1

Input::
* _Commitment Master Public Key_

Output::
* _Public Key Share Commitment_

//-

. Each signer generates _ECDSA Key Share_ which consists of _ECDSA Private Key Share_ 
and _ECDSA Public Key Share_.
+
_ECDSA Private Key Share_ value must be kept secret and never shared in a plaintext 
form.
+
_ECDSA Public Key Share_ value cannot be exposed until all signers in the group 
commit to their values.

. Each signer calculates a commitment to the _ECDSA Public Key Share_ value and 
publishes this commitment in  _PublicKeyShareCommitmentMessage_.

.PublicKeyShareCommitmentMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`publicKeyShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _ECDSA Public Key Share_
|=== 

==== Round #2

Input::
* _ECDSA Public Key Share Commitment_

Output::
* _ECDSA Key_ {_Encrypted ECDSA Private Key_, _ECDSA Public Key_}

//-

After commitments from all signers are gathered the second round starts.

. Signers reveal their _ECDSA Key Shares_ and send _KeyShareRevealMessage_. 
+
Since _ECDSA Private Key Share_ should always be kept secret it is first encrypted with
Paillier and this encrypted value is published along with Zero Knowledge Proof 
Π~i~, which states that:
+
****
∃ _secretKeyShare_ ∈ [-q^3^, q^3^] such that

_g_^_secretKeyShare_^ = _publicKeyShare_

D(_encryptedSecretKeyShare_) = _secretKeyShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
****
+
_ECDSA Public Key Share_ is published with a decommitment key used in a previous 
round to produce commitment to _ECDSA Public Key Share_ value.
+
.KeyShareRevealMessage
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`secretKeyShare` 
^|`paillier.Cypher`
^|Encrypted _ECDSA Private Key Share_

^|`publicKeyShare` 
^|`curve.Point`
^|_ECDSA Public Key Share_

^|`publicKeyShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for _ECDSA Public Key Share_

^|`secretKeyProof` 
^|`zkp.DsaPaillierKeyRangeProof`
^|ZKP Π~i~
|=== 

. Each signer validates received _KeyShareRevealMessages_ and combines shares 
to get encrypted _ECDSA Private Key_ and _ECDSA Public Key_ which together form 
_ECDSA Key_.

=== Signing

==== Round #1 [[sign_round_1]]

Input::
* _Encrypted ECDSA Private Key_
* _Commitment Master Public Key_

Output::
* _ECDSA Private Key Factor Share Commitment_

//-

. Each signer generates _Encrypted ECDSA Private Key Factor Share_ and 
_ECDSA Private Key Multiple Share_. These values are kept private for now. +

. Signer calculates a commitment to both values and publishes the commitment in 
_SignRound1Message_.
+
.SignRound1Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`secretKeyFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_
|=== 

==== Round #2 [[sign_round_2]]

Output::
* _Encrypted ECDSA Private Key Factor Share_
* _ECDSA Private Key Multiple Share_
* Decommitment key for _ECDSA Private Key Factor Share Commitment_
* _Zero Knowledge Proof Π~1,i~_

//-

. Each signer calculates a Zero Knowledge Proof Π~1,i~ for his individual parameters,
which states that:
+
****
∃ _secretKeyFactorShare_ ∈ [-q^3^, q^3^] such that

D(_encryptedSecretKeyFactorShare_) = _secretKeyFactorShare_

D(_secretKeyMultipleShare_) = _secretKeyFactorShare_ * D(_secretKey_)

where _q_ is an order of an Elliptic Curve and D is a Decrypt function of a Paillier scheme
****

. Signers publish _SignRound2Message_ containing _ECDSA Private Key Factor Share_, 
_ECDSA Private Key Multiple Share_ and decommitment key for the commitment from 
<<sign_round_1>>.
+
.SignRound2Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`secretKeyFactorShare` 
^|`paillier.Cypher`
^|_ECDSA Private Key Factor Share_

^|`secretKeyMultipleShare` 
^|`paillier.Cypher`
^|_ECDSA Private Key Multiple Share_

^|`secretKeyFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment to _ECDSA Private Key Factor Share_ and _ECDSA Private Key Multiple Share_

^|`secretKeyFactorProof` 
^|`zkp.DsaPaillierSecretKeyFactorRangeProof`
^|ZKP Π~1,i~
|=== 

. Signer validates received _SignRound1Messages_ and _SignRound2Messages_. +
Combines shares to get _ECDSA Private Key Factor_ and _ECDSA Private Key Multiple_.

==== Round #3 [[sign_round_3]]

Input::
* _ECDSA Private Key Factor_
* _ECDSA Private Key Multiple_
* _Commitment Master Public Key_

Output::
* _Signature Factor Share Commitment_

//-

. Each signer computes a set of parameters: _Signature Factor Public Share_, and 
_Signature Unmask Share_ and calculates a commitment to these
values. All the parameters are kept private for now, they will be used later to
compute the final signature.

. Signer publishes the commitment in a _SignRound3Message_.
+
.SignRound3Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signatureFactorShareCommitment` 
^|`commitment.MultiTrapdoorCommitment`
^|Commitment to parameters from <<sign_round_3>>
|=== 

==== Round #4 [[sign_round_4]]

Output::
* _Signature Factor Public Share_
* _Signature Unmask Share_
* Decommitment key for _Signature Factor Share Commitment_
* _Zero Knowledge Proof Π~2,i~_

//-

This round starts after all signers share their commitments in <<sign_round_3>>.

. Each signer calculates a Zero Knowledge Proof Π~2,i~ for his individual parameters,
which states that:
+
****
∃ _signatureFactorSecretShare_ ∈ [-q^3^, q^3^], _signatureFactorPublicShare_ ∈ [-q^8^, q^8^] such that

_g_^_signatureFactorSecretShare_^ = _signatureFactorPublicShare_

D(_signatureUnmaskShare_) = _signatureFactorSecretShare_ × D(_secretKeyFactor_) + _q_ × _signatureFactorMaskShare_

where _q_ is an order and _g_ is a generator point of an Elliptic Curve and 
D is a Decrypt function of a Paillier scheme
****

. Signers publish _SignRound4Message_ containing the Zero Knowledge Proof Π~2,i~,
along with parameters and decommitment key from the <<sign_round_3>>.
+
.SignRound4Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signatureFactorPublicShare` 
^|`curve.Point`
^|_Signature Factor Public Share_

^|`signatureUnmaskShare` 
^|`paillier.Cypher`
^|_Encrypted Signature Unmask Share_

^|`signatureFactorShareDecommitmentKey` 
^|`commitment.DecommitmentKey`
^|Decommitment key for a commitment from <<sign_round_3>>

^|`signatureFactorProof` 
^|`zkp.EcdsaSignatureFactorRangeProof`
^|ZKP Π~2,i~
|=== 

. Signer validates received _SignRound3Messages_ and _SignRound4Messages_. +
Combines shares to get _Signature Factor Public_ and _Encrypted Signature Unmask_.

==== Round #5 [[sign_round_5]]

Input::
* _Signature Factor Public_
* _Encrypted Signature Unmask_

Output::
* _Signature Unmask Partial Decryption_

//-

. Each signer computes hash of _Signature Factor Public_ parameter.

. Signers jointly decrypt _Encrypted Signature Unmask_ with Paillier, so each signer
receives just a partial decryption of _Signature Unmask_.

. Signer publishes _SignRound5Message_.
+
.SignRound5Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signatureUnmaskPartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature Unmask_ partial decryption.
|=== 

. Signer validates received _SignRound5Messages_. +
Combines partial decryptions to get _Signature Unmask_.

==== Round #6 [[sign_round_6]]

Input::
* _Signature Unmask_
* _Message Hash_

Output::
* _Signature Partial Decryption_

//-

. Each signer computes _Encrypted Signature_ value for a _Message Hash_ with 
_Signature Unmask_, _Signature Factor Public Hash_ and encrypted _ECDSA Private Key Factor_ 
and _ECDSA Private Key Multiple_. +
It's possible to perform a computation on Paillier-encrypted parameters because 
it's an additively homomorphic scheme.

. Signers jointly decrypt the computed _Encrypted Signature_, so each signer receives 
a partial decryption of _Signature_.

. Signer publishes _SignRound6Message_.
+
.SignRound6Message
[halign=center,options="header"]
|=== 
^|name ^|type ^|description

^|`signaturePartialDecryption` 
^|`paillier.PartialDecryption`
^|_Signature.S_ partial decryption.
|=== 

. Signer validates received _SignRound6Messages_ and combines partial decryptions 
to get _Signature_.

. Signer produces a _T-ECDSA Signature_ in {R,S} format where:
[horizontal]
R:: Hash of _Signature Factor Public_
S:: _Signature_
