= Distributed Key Generation

:toc: macro
:toclevels: 4

The DKG scheme proposal is based on a protocol by
Gennaro, Jarecki, Krawczyk and Rabin <<GJKR>>.
GJKR is further based on Pedersen-VSS (verifiable secret sharing) <<Ped>>.
For this implementation, GJKR has been modified
to make protocol violations objectively attributable
and remove the need for one-to-one messaging channels.

The protocol uses ephemeral ECDH keys
to encrypt one-to-one communication on the broadcast channel.
This ensures that participants can neither
make baseless complaints nor
cause a minor nuisance with subtle misbehavior.

Additionally, the threshold relay public key submission protocol
is defined.

toc::[]

== Tech

=== Broadcast channel

Every group member in phase _p_ can safely assume
every non-inactive group member has seen
all messages broadcast within _t~p~_ after the beginning of phase _p_.

All messages broadcast by _P~i~_ are assumed to be signed with _X~i~_.

A message is malformed if it cannot be parsed and validated
as the message required in a particular phase of the protocol.

== Terms

.Global constants
|===
|Variable |Meaning

|_n = 2f~max~ + 1 = 4f~fail~ + 1_
|Number of nodes in a group

|_f~max~ = (n - 1)/2_
|Threshold of maximum malicious nodes in a group

|_f~fail~ = f~max~/2 = (n - 1)/4_
|Threshold of inactive or misbehaving nodes
beyond which the DKG does not finish
|===

.Time limits
|===
|Variable |Meaning
|_t~dkg~_
|Time limit for the distributed key generation to finish
and _P~1~_ to submit the result

|_t~step~_
|Time limit after which
the next participant in line
becomes eligible to submit the result

|_t~conflict~_
|Time limit after which
any disputes over the correct result are assumed to be resolved,
with the plurality being honest
|===

.Values at the time of group creation
|===
|Variable |Meaning
|_V~i~_
|__i__th output of the random beacon

|_N_
|The set of all stakers at the time of _V~i~_

|_G_
|The candidate group generated from _V~i~_ and _N_

|_P~i~_
|__i__th node in _G_ based on the group candidate selection algorithm
|===

.Values in the DKG protocol
|===
|Variable |Meaning
|_IA~p~_
|The set of nodes in _G_ that first failed to broadcast a required message within
a specified time limit in phase _p_ and were thus added to the set of inactive
nodes after that phase

|_IA = IA~1~ + IA~2~ + ..._
|The set of inactive nodes in _G_ (nodes that failed to broadcast a required
message within a specified time limit during the DKG)

|_DQ~p~_
|The set of nodes in _G_ that were disqualified in phase _p_ for provably and
attributably violating the protocol

|_DQ = DQ~1~ + DQ~2~ + ..._
|The set of all disqualified nodes in _G_

|_G~p~ = G~p-1~ - IA~p-1~ - DQ~p-1~_
|The set of nodes in _G_ that were active and well-behaved at the
beginning of phase _p_ (_G~1~ = G_)

|_G' = G - IA - DQ_
|The successfully created group after removal of inactive
and misbehaving nodes

|_QUAL = G~6~_
|A special name for the set of participants whose input is included
in the final outputs of the DKG protocol
|===

.Keys
|===
|Variable |Meaning
|_X~i~_
|Long-term ECDSA private key of _P~i~_

|_Y~i~_
|Long-term ECDSA public key of _P~i~_

|_X~ij~_
|Ephemeral ECDH private key of _P~i~_ for the purpose of encrypted communication
with _P~j~_

|_Y~ij~_
|Ephemeral ECDH public key of _P~i~_ for the purpose of encrypted communication
with _P~j~_

|_K~ij~ = K~ji~ = ECDH(X~ij~, Y~ji~)_
|Symmetric key generated by _P~i~_ for encrypting and decrypting communications
with _P~j~_

|_X_
|The (virtual) private key corresponding to the group _G'_

|_Y_
|The public key corresponding to the group _G'_
|===


== Protocol

Input: _V~i~, N_

Output: one of

* Successfully generated group _G'_ including
** public key _Y_ of _G'_
** lists of absent and disqualified nodes _IA_ and _DQ_
* Failure to generate a valid group including
** list of disqualified nodes _DQ_

The group generation protocol selects a new candidate group _G_ from _N_
and runs a distributed key generation (DKG) protocol
to create a threshold signature public key _Y_ for the group,
to be used in the random beacon.

After a successful execution of the protocol,
_G'_ will be the group of nodes
that may participate in the random beacon signing,
having been neither inactive or misbehaving during the DKG.

Inactive nodes will be removed from _G'_
and not be eligible for the rewards
from participating in the random beacon
by contributing to the signature _v~j~_
should _G'_ be chosen as the group to produce
the __j__th random number from the beacon.

Disqualified nodes will be removed from _G'_
and their stake will be slashed in punishment
for provably and attributably acting in breach of the DKG protocol.

=== Group Selection

_TBD_

Input: _V~i~_, _N_

Output: _[Y~1~, Y~2~, ... Y~N~]_

For the purposes of the DKG algorithm,
group selection can be left undefined for now.
The protocol requires an ordered list of node identifiers,
represented here as public keys of participants _P~1~_ to _P~N~_.
This list is produced from _P_ using _V~i~_ as input.

=== Distributed Key Generation

Phases are seen from the perspective of _P~i~_

After phase _p_, the nodes that failed to broadcast a required message
will be added to _IA~p~_.
Nodes that broadcast a malformed message may be added to _IA~p~_ or _DQ~p~_.

==== Phase 1. Ephemeral key generation

To ensure integrity in later parts of the DKG protocol,
we will require every _P~i~_ to generate
an ephemeral ECDH keypair _(X~ij~, Y~ij~)_ for every other member _P~j~_ in _G_.
These will be broadcast in _phase 1_.

[source]
----
# Receive:

[Y_1, Y_2, ... Y_N] # <1>

# Calculate:

t_init = getCurrentBlockHeight()

for P_j in G, P_j /= P_i:
  (X_ij, Y_ij) = genEcdhKeypair()

[X_i1, X_i2, ... X_iN] # <2>

[Y_i1, Y_i2, ... Y_iN] # <3>

# Broadcast:

[Y_i1, Y_i2, ... Y_iN]
----

<1> Identifiers of participants in candidate group _G_
<2> Private keys for communicating with other participants in _G_
<3> Public keys for communicating with other participants in _G_

==== Phase 2. Ephemeral ECDH

Every node in _G_ has now published a valid list of ephemeral ECDH pubkeys.
_P~i~_ will perform ECDH with every _P~j~_ in _G_ to create _K~ij~_.

[source]
----
# Receive:

[[Y_12, Y_13, ... Y_1i, ... Y_1N],
 [Y_21, Y_23, ... Y_2i, ... Y_2N],
 ...
 [Y_N1, Y_N2, ... Y_Ni, ... Y_N(N-1)]] # <1>

# Calculate:

(G_2, IA_1, DQ_1) = checkBroadcast(1, G_1) # <<2>>

for P_j in G_2:
   K_ij = ecdh(X_ij, Y_ji)
----

<1> Public keys of all other participants in _G_
<2> A validation function which determines which nodes
have broadcast the correct message for phase _p_

==== Phase 3. Polynomial generation

Every node in _G~3~_ has, for every other node in _G~3~_, a symmetric key that
can be used for encrypted and attributable communications over the broadcast
channel. The Pedersen-VSS phase of the GJKR DKG algorithm can commence.

Create two polynomials _f~i~(z)_ and _f'~i~(z)_ of degree _T_ and calculate
other players' shares as points on these polynomials. Additionally, calculate
Pedersen commitments to the coefficients of _f~i~(z)_ using the coefficients
of _f'~i~(z)_.

Shares to _P~j~_ are encrypted with the symmetric key _K~ij~ = K~ji~_
shared by _P~i~_ and _P~j~_.
Commitments and encrypted shares are broadcast to other players.


[source]
----
# Calculate:

G_3 = G_2

for j in [0..T]:
  a_ij = random(Z_q)
  b_ij = random(Z_q)

f_i(z) = sum(
  for j in [0..T]:
    a_ij * z^j
)

f'_i(z) = sum(
  for j in [0..T]:
    b_ij * z^j
)

z_i = a_i0 = f_i(0) # <1>

commitments_i =
  for k in [0..T]:
    C_ik = g^a_ik * h^b_ik mod p # <2>

encryptedShares_i =
  for j in G_3:
    s_ij = f_i(j) mod q
    s'_ij = f'_i(j) mod q

    E_ij = encrypt(K_ij, (s_ij, s'_ij)) # <3>

# Broadcast:

(encryptedShares_i, commitments_i)
----

<1> _P~i~_'s share of the shared secret key
<2> Pedersen commitments to coefficients
<3> Shares for _P~j~_ encrypted with the shared symkey

==== Phase 4: Share verification

Receive, decrypt and validate shares from other participants. If any share
fails to pass validation, broadcast a complaint by publishing the corresponding
ephemeral private key so others can validate the result.

[source]
----
# Receive:

[(encryptedShares_1, commitments_1),
 ...
 (encryptedShares_N, commitments_N)]

# Calculate:

(G_4, IA_3, DQ_3) = checkBroadcast(3, G_3)

complaints_Ai = []

for j in G_4:
  E_ji = encryptedShares_j[i]

  (s_ji, s'_ji) = decrypt(K_ij, E_ji)

  C_prod = product(
    for k in [0..T]:
      commitments_j[k] ^ (i^k)
  ) mod p

  if g^s_ji * h^s'_ji /= C_prod:
    complaints_i += X_ij # <<1>>

# Broadcast:

complaints_Ai
----

<<1>> Publish the private key _P~i~_ created for communicating with _P~j~_,
so anyone can decrypt and verify the shares _P~i~_ received from _P~j~_.

==== Phase 5: First complaint resolution

If anyone has complaints about another player, use the published privkeys
to decrypt transmitted messages and determine fault. With every complaint, one
party can be proven to be at fault and thus disqualified.

[source]
----
# Receive:

[complaints_A1, complaints_A2, ... ]

# Calculate:

(G_5, IA_4, DQ_4) = checkBroadcast(4, G_4)

DQ_5 = []

complaints_A = union(complaints_A1, complaints_A2, ...)

for c in complaints_A:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, s'_mj) = decrypt(K_jm, E_mj)

  C_prod = product(
    for k in [0..T]:
      C_jk ^ (m^k)
  ) mod p

  if g^s_mj * h^s'_mj = C_prod:
    DQ_5 += P_j
  else:
    DQ_5 += P_m
----

Disqualify players that either delivered invalid shares, or made a false
complaint against a player that delivered valid shares.


==== Phase 6: Share calculation

Each player sets their share _x~i~_ of the secret _X_ to equal the sum of all
shares _s~ji~_ as per GJKR. _X_ equals the sum of shares _s~j0~_.

[source]
----
# Calculate:

G_6 = G_5 - DQ_5

x_i = sum(
  for j in G_6:
    s_ji
) mod q

x'_i = sum(
  for j in G_6:
    s'_ji
) mod q
----


==== Phase 7: Public key share points

Each player broadcasts their _A~ik~_ values.

[source]
----
# Calculate:

G_7 = G_6

for k in [0..T]:
  A_ik = g^a_ik mod p

# Broadcast:

[A_i0, A_i1, ... A_iT]
----

==== Phase 8: Public key share validation

Each player validates the values received in the previous step.

[source]
----
# Receive:

[[A_10, A_11, ... A_1T], ...]

# Calculate:

(G_8, IA_7, DQ_7) = checkBroadcast(7, G_7)

complaints_Bi = []

for j in G_8:
  A_prod = product(
    for k in [0..T]:
      A_jk ^ (i^k)
  ) mod p

  if g^s_ji /= A_prod:
    complaints_B += X_ij

# Broadcast:

complaints_Bi
----

==== Phase 9: Second complaint resolution

As in Phase 5, but with the validation formula from Phase 8.

It should be noted that the symmetric nature of the encryption
allows the parties to also decrypt _E~jm~_ and not just _E~mj~_.
This is not very significant though,
as even the publication of only the misbehaving participants' shares
would reduce the security margin excessively
if a large fraction of _G_ were to misbehave.
By setting the threshold for group creation failure at _f~max~/2_
the impact of this is reduced to a manageable level.

[source]
----
# Receive:

[complaints_B1, complaints_B2, ...]

# Calculate:

(G_9, IA_8, DQ_8) = checkBroadcast(8, G_8)

DQ_9 = []

complaints_B = union(complaints_B1, complaints_B2, ...)

for c in complaints_B:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, s'_mj) = decrypt(K_jm, E_mj)

  A_prod = product(
    for k in [0..T]:
      A_mk ^ (j^k)
  ) mod p

  if g^s_mj = A_prod:
    DQ_9 += P_j
  else:
    DQ_9 += P_m
----

==== Phase 10: Disqualified share opening

All non-disqualified players in _QUAL_ broadcast the keys they share with
players in _DISQUAL_, so the reconstruction of Pedersen-VSS can be done
offline.

[source]
----
# Calculate:

G_10 = G_9 - DQ_9

keys_i = []

for m in DQ_9:
  keys_i += X_im

# Broadcast:

if keys_i /= []:
  keys_i
----

==== Phase 11: Disqualified share reconstruction

Decrypt and reconstruct _z~m~_ for every participant _P~m~_ that presented
valid shares in _phase 4_ but whose public key shares in _phase 7_ were invalid.

[source]
----
# Receive:

[keys_1, keys_2, ... , keys_N]

# Calculate:

(G_11, IA_10, DQ_10) = checkBroadcast(10, G_10)

for m in (G_6 - G_11): # <<1>>
  for j in G':
    X_jm = keys_j[m]

    K_jm = ecdh(X_jm, Y_mj)

    (s_mj, s'_mj) = decrypt(K_jm, E_mj)

  ss_m = take(T + 1, [s_m1, ... , s_mN])

  is_m = [s.index for s in ss_m]

  z_m = sum(
    for k in is_m, s_mk in ss_m:
      a_mk = product(
        for l in is_m, l /= k:
          k / (k - l)
      )
      s_mk * a_mk
  )
----
<<1>> Reconstruct the shares of participants that became inactive
or were disqualified since _phase 6_

==== Phase 12: Public key reconstruction

Let _G~12~ = G~11~_

Combine _y~j~_ for all participants in _QUAL_ to reconstruct the public key for
the group.

[source]
----
# Calculate:

for j in QUAL:
  y_j = A_j0 = g^z_j mod p

Y = product(
  for j in QUAL:
    y_j
) mod p
----


==== Phase 13: Result publication

Let _IA = IA~1~ + IA~2~ + ... + IA~10~_

Let _DQ = DQ~1~ + DQ~2~ + ... + DQ~10~_

Player _P~1~_ is the participant designated to submit the result on-chain.
However, if _P~1~_ does not submit a transaction within _t~dkg~_ blocks, _P~2~_
becomes eligible to submit the public key. After _t~dkg~ + t~step~_ blocks,
_P~3~_ becomes eligible, after _t~dkg~ + 2 * t~step~_ blocks _P~4~_, and so on.

When _P~j~_ submits the result, players _P~k~ | k < j_ will face a small
penalty for being late, while _P~j~_ will receive the submission reward.

[source]
----
if nPlayers(IA + DQ) > T/2:
  correctResult = makeFailure(DQ)
else:
  correctResult = makeSuccess(Y, IA, DQ)

resultHash = hash(correctResult)

alreadySubmitted = False
resultPublished = False
finished = False

while !resultPublished:
  t_now = getCurrentBlockHeight()

  # using t_init from phase 1
  t_elapsed = t_now - t_init

  # determine highest index j eligible to submit
  if t_elapsed <= t_dkg:
    j = 1
  else:
    t_over = t_elapsed - t_dkg
    j = 1 + ceiling(t_over / t_step)

  if j >= i:
    broadcast(correctResult)
    resultPublished = True
    alreadySubmitted = True
  else:
    resultPublished = checkChainForResult()
----

==== Phase 14: Result conflict resolution

Because of the honest majority assumption, we can expect the result at least
_T + 1_ participants support to be correct.

If any participant disputes a result submitted on-chain, they can submit a
different one.

If any participant disputes the submitted result that currently has the greatest
number of signatures on-chain, believing a different result submitted on-chain
to be the correct one, they can publish a support message by publishing a
hash of their preferred result
(implicitly authenticated with the signature inherent in publishing on-chain).

Any participant can only vote for one submitted result, by submitting it or
publishing a support message for it.

Because of the available honest majority assumption, we can expect that any
result that is not at the lead after _t~conflict~_ time has elapsed has
acquired its maximum number of signatures it would be able to receive, and
thus the result receiving the plurality of support is the correct one.

An exception to this is if the total number of signatures supporting all other
submitted results is higher than _T_, in which case the result is declared a
failure without disqualifications.

[source]
----
while resultPublished && !finished:
  allResults = getSubmissions()
  leadResult = allResults.mostVotes

  t_now = getCurrentBlockHeight()
  t_first = allResults.earliest.submitTime

  if t_now > t_first + t_conflict || leadResult.votes > T:
    finished = True

  elif correctResult = leadResult || alreadySubmitted:
    wait()

  elif correctResult in allResults:
    submit(sign(resultHash))
    alreadySubmitted = True

  else:
    submit(correctResult)
    alreadySubmitted = True
----

From the perspective of the chain:

[source]
----
eligibleSubmitter(P_i) =
  t_now = getCurrentBlockHeight()
  t_elapsed = t_now - t_init

  i = P_i.index

  if i == 1:
    True
  elif t_elapsed >= t_dkg + (i-2) * t_step:
    True
  else:
    False

receivedSubmissions = {}
memberVotes = {}
submissionVotes = {}

receiveSubmission(s) =
  P_s = s.sender
  hs = hash(s)

  # when the submission is the first one
  if receivedSubmissions == {}:
    if eligibleSubmitter(P_s):
      receivedSubmissions[hs] = s
      memberVotes[P_s] = hs
      submissionVotes[hs] = 1
    else:
      reject(s)

  # when the submission is challenging another one
  else:

    # don't allow double voting
    if memberVotes[P_s]:
      reject(s)

    # new submission
    elif !receivedSubmissions[hs]:
      receivedSubmissions[hs] = s
      memberVotes[P_s] = hs
      submissionVotes[hs] = 1

    # existing submission
    else:
      memberVotes[P_s] = hs
      submissionVotes[hs] += 1
----

[bibliography]
== References

- [[[GJKR]]] Gennaro R., Jarecki S., Krawczyk H., Rabin T. (1999)
Secure Distributed Key Generation for Discrete-Log Based Cryptosystems.
In: Stern J. (eds) Advances in Cryptology — EUROCRYPT ’99. EUROCRYPT 1999.
Lecture Notes in Computer Science, vol 1592. Springer, Berlin, Heidelberg

- [[[Ped]]] Pedersen T.P. (1992)
Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing.
In: Feigenbaum J. (eds) Advances in Cryptology — CRYPTO ’91. CRYPTO 1991.
Lecture Notes in Computer Science, vol 576. Springer, Berlin, Heidelberg
