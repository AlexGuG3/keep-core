:toc: macro

= Distributed Key Generation

:toclevels: 4

The DKG scheme proposal is based on a protocol by
Gennaro, Jarecki, Krawczyk and Rabin <<GJKR>>.
GJKR is further based on Pedersen-VSS (verifiable secret sharing) <<Ped>>.
For this implementation, GJKR has been modified
to make protocol violations objectively attributable
and remove the need for one-to-one messaging channels.

The protocol uses ephemeral ECDH keys
to encrypt one-to-one communication on the broadcast channel.
This ensures that participants can neither
make baseless complaints nor
cause a minor nuisance with subtle misbehavior.

Additionally, the threshold relay public key submission protocol
is defined.

toc::[]

== Details+Rationale

=== Message delivery

==== Broadcast channel

Every group member in phase _p_ can safely assume
every non-inactive group member has seen
all messages broadcast within _t~p~_ after the beginning of phase _p_.

All messages broadcast by _P~i~_ are assumed to be signed with _X~i~_.

A message is malformed if it cannot be parsed and validated
as the message required in a particular phase of the protocol.

===== Assumptions and implications

The broadcast channel is assumed to give all participants
the same view of the world,
and deliver all messages from non-inactive participants
within a time that is less than the applicable time limit for each phase.

If these assumptions don't hold, certain attacks become possible.
For example, if a message from _P~i~_
reaches honest participant _P~j~_ but not _P~k~_,
their sets of inactive participants _IA~Pj~_ and _IA~Pk~_ will differ.
This will make them vote for different results,
which will prevent quorum from being reached on _full verification_,
while on _escalating votes_ a coordinating adversary
could make its preferred incorrect result win the vote.
To protect against the latter,
_escalating votes_ assumes a null result when any single result is opposed
by _f~max~ + 1_ participants as it means that the honest votes are split.

=== Dispute resolution

Given that the protocol is performed off-chain,
participants may submit incorrect results
in an attempt to gain advantage.
By relying on the honest majority assumption,
this can be mitigated by having participants vote on results.

There are two main ways this voting can be performed:
either by members signing valid results, which are then verified on-chain,
or by designated members being eligible to submit a result
which may be challenged by others if they consider it incorrect.

==== Full verification

The _full verification_ technique of voting is simple.
The designated eligible submitter _P~sub~_ publishes the correct result
which is then checked by the contract to contain at least _f~max~ + 1_
valid signatures from unique members of _G_.

This technique requires fewer transactions and is less complex to implement,
but bears a constant cost as _O(n)_ signatures must be validated on-chain
upon every group creation.
Assuming for the sake of example _n = 201_ and _f~max~ = 100_,
and that `ecrecover = 3000 gas` dominates the transaction fees,
the cost of full verification would be constant on the order of 325,000 gas.

This also sets a hard limit on the group size of _n < gasLimit / 3000_,
but in practice this would only happen with impractically large groups
(currently more than 2,000 participants).

It is easy to see why _full verification_ would be correct:
if _f~max~_ is the largest number of malicious participants,
requiring _f~max~ + 1_ signatures means that any result accepted by the system
must have at least one honest participant supporting it.

==== Escalating votes

As an alternative to the above,
_escalating votes_ is a protocol where a result is submitted,
and accepted if it is not challenged within a specified time limit.
If multiple results are presented,
the participants will proceed to submit votes on the results
iff their preferred result is not in the lead,
or their vote would break a tie.
After a certain time limit has elapsed since the last vote,
a confirmation request transaction may be presented by anybody,
and the result with the highest number of supporting votes is accepted.

The security of this scheme is less obvious,
but follows from the honest majority assumption:
since at least _f~max~ + 1_ honest players are online at the voting stage,
for any amount of adversary votes _0 < V~m~<= f~max~_
there will be _V~m~ + 1_ honest participants
who will outvote the malicious players
(proof by induction).

This scheme is only suitable for situations where _n >= 2 * f~max~ + 1_,
due to the reliance on the honest majority assumption.
If the majority of participants is dishonest,
the plurality result may be incorrect.

In the worst-case scenario escalating votes will cost
_(f~max~ + 2) * 21000_ gas to the honest participants,
or around 2.15 million gas.
However, the practical cost of using escalating votes would be variable
and would be expected to be significantly lower most of the time.

Given that a rational adversary who cannot break the honest majority assumption
will expect to inevitably lose the escalating vote,
and the cost of the voting is symmetrical
(submitting one vote costs approximately 21,000 gas,
so the malicious players will pay _V~m~ * 21000_ gas
while honest players will pay _(V~m~ + 2) * 21000_ gas in total;
this means the honest players will always pay exactly
42,000 gas more than the malicious players regardless of the value of _V~m~_),
one would expect the escalating votes to usually go unchallenged.

In the example scenario, escalating votes is cheaper than full verification
if the average number of votes supporting the highest-voted incorrect result
is less than 13 out of 200 participants,
or alternatively if the worst-case scenario occurs at most 1/8 the time.

== Terms

.Global constants
|===
|Variable |Meaning

|_n = 2f~max~ + 1 = 4f~fail~ + 1_
|Number of nodes in a group

|_f~max~ = (n - 1)/2_
|Threshold of maximum malicious nodes in a group

|_f~fail~ = f~max~/2 = (n - 1)/4_
|Threshold of inactive or misbehaving nodes
beyond which the DKG does not finish
|===

.Time limits
|===
|Variable |Meaning
|_t~dkg~_
|Time limit for the distributed key generation to finish
and _P~1~_ to submit the result

|_t~step~_
|Time limit after which
the next participant in line
becomes eligible to submit the result

|_t~conflict~_
|Time limit after which
any disputes over the correct result are assumed to be resolved,
with the plurality being honest
|===

.Values at the time of group creation
|===
|Variable |Meaning
|_V~i~_
|__i__th output of the random beacon

|_N_
|The set of all stakers at the time of _V~i~_

|_G_
|The candidate group generated from _V~i~_ and _N_

|_P~i~_
|__i__th node in _G_ based on the group candidate selection algorithm
|===

.Values in the DKG protocol
|===
|Variable |Meaning
|_IA~p~_
|The set of nodes in _G_ that first failed to broadcast a required message within
a specified time limit in phase _p_ and were thus added to the set of inactive
nodes after that phase

|_IA = IA~1~ + IA~2~ + ..._
|The set of inactive nodes in _G_ (nodes that failed to broadcast a required
message within a specified time limit during the DKG)

|_DQ~p~_
|The set of nodes in _G_ that were disqualified in phase _p_ for provably and
attributably violating the protocol

|_DQ = DQ~1~ + DQ~2~ + ..._
|The set of all disqualified nodes in _G_

|_G~p~ = G~p-1~ - IA~p-1~ - DQ~p-1~_
|The set of nodes in _G_ that were active and well-behaved at the
beginning of phase _p_ (_G~1~ = G_)

|_G' = G - IA - DQ_
|The successfully created group after removal of inactive
and misbehaving nodes
|===

.Keys
|===
|Variable |Meaning
|_X~i~_
|Long-term ECDSA private key of _P~i~_

|_Y~i~_
|Long-term ECDSA public key of _P~i~_

|_X~ij~_
|Ephemeral ECDH private key of _P~i~_ for the purpose of encrypted communication
with _P~j~_

|_Y~ij~_
|Ephemeral ECDH public key of _P~i~_ for the purpose of encrypted communication
with _P~j~_

|_K~ij~ = K~ji~ = ECDH(X~ij~, Y~ji~)_
|Symmetric key generated by _P~i~_ for encrypting and decrypting communications
with _P~j~_

|_X_
|The (virtual) private key corresponding to the group _G'_

|_Y_
|The public key corresponding to the group _G'_
|===


== Protocol

Input: _V~i~, N_

Output: one of

* Successfully generated group _G'_ including
** public key _Y_ of _G'_
** lists of absent and disqualified nodes _IA_ and _DQ_
* Failure to generate a valid group including
** list of disqualified nodes _DQ_

The group generation protocol selects a new candidate group _G_ from _N_
and runs a distributed key generation (DKG) protocol
to create a threshold signature public key _Y_ for the group,
to be used in the random beacon.

After a successful execution of the protocol,
_G'_ will be the group of nodes
that may participate in the random beacon signing,
having been neither inactive or misbehaving during the DKG.

Inactive nodes will be removed from _G'_
and not be eligible for the rewards
from participating in the random beacon
by contributing to the signature _v~j~_
should _G'_ be chosen as the group to produce
the __j__th random number from the beacon.

Disqualified nodes will be removed from _G'_
and their stake will be slashed in punishment
for provably and attributably acting in breach of the DKG protocol.

=== Group Selection

_TBD_

Input: _V~i~_, _N_

Output: _[Y~1~, Y~2~, ... Y~N~]_

For the purposes of the DKG algorithm,
group selection can be left undefined for now.
The protocol requires an ordered list of node identifiers,
represented here as public keys of participants _P~1~_ to _P~N~_.
This list is produced from _P_ using _V~i~_ as input.

=== Distributed Key Generation

Phases are seen from the perspective of _P~i~_

After phase _p_, the nodes that failed to broadcast a required message
will be added to _IA~p~_.
Nodes that broadcast a malformed message may be added to _IA~p~_ or _DQ~p~_.

==== Phase 1. Ephemeral key generation

To ensure integrity in later parts of the DKG protocol,
we will require every _P~i~_ to generate
an ephemeral ECDH keypair _(X~ij~, Y~ij~)_ for every other member _P~j~_ in _G_.
These will be broadcast in _phase 1_.

[source, python]
----
# Receive:

[Y_1, Y_2, ... Y_N] # <1>

# Calculate:

t_init = getCurrentBlockHeight()

for P_j in G, P_j /= P_i:
  (X_ij, Y_ij) = genEcdhKeypair()

[X_i1, X_i2, ... X_iN] # <2>

[Y_i1, Y_i2, ... Y_iN] # <3>

# Broadcast:

[Y_i1, Y_i2, ... Y_iN]
----

<1> Identifiers of participants in candidate group _G_
<2> Private keys for communicating with other participants in _G_
<3> Public keys for communicating with other participants in _G_

==== Phase 2. Ephemeral ECDH

Every node in _G_ has now published a valid list of ephemeral ECDH pubkeys.
_P~i~_ will perform ECDH with every _P~j~_ in _G_ to create _K~ij~_.

[source, python]
----
# Receive:

[[Y_12, Y_13, ... Y_1i, ... Y_1N],
 [Y_21, Y_23, ... Y_2i, ... Y_2N],
 ...
 [Y_N1, Y_N2, ... Y_Ni, ... Y_N(N-1)]] # <1>

# Calculate:

(G_2, IA_1, DQ_1) = checkBroadcast(1, G_1) # <2>

for P_j in G_2:
   K_ij = ecdh(X_ij, Y_ji)
----

<1> Public keys of all other participants in _G_
<2> A validation function which determines which nodes
have broadcast the correct message for phase _p_

==== Phase 3. Polynomial generation

Every node in _G~3~_ has, for every other node in _G~3~_, a symmetric key that
can be used for encrypted and attributable communications over the broadcast
channel. The Pedersen-VSS phase of the GJKR DKG algorithm can commence.

Create two polynomials _f~i~(z)_ and _g~i~(z)_ of degree _T_ and calculate
other playersg shares as points on these polynomials. Additionally, calculate
Pedersen commitments to the coefficients of _f~i~(z)_ using the coefficients
of _g~i~(z)_.

Shares to _P~j~_ are encrypted with the symmetric key _K~ij~ = K~ji~_
shared by _P~i~_ and _P~j~_.
Commitments and encrypted shares are broadcast to other players.


[source, python]
----
# Calculate:

G_3 = G_2

for j in [0..T]:
  a_ij = random(Z_q)
  b_ij = random(Z_q)

f_i(z) = sum(
  for j in [0..T]:
    a_ij * z^j
)

g_i(z) = sum(
  for j in [0..T]:
    b_ij * z^j
)

z_i = a_i0 = f_i(0) # <1>

commitments_i =
  for k in [0..T]:
    C_ik = g^a_ik * h^b_ik mod p # <2>

encryptedShares_i =
  for j in G_3:
    s_ij = f_i(j) mod q
    sg_ij = g_i(j) mod q

    E_ij = encrypt(K_ij, (s_ij, sg_ij)) # <3>

# Broadcast:

(encryptedShares_i, commitments_i)
----

<1> _P~i~_'s share of the shared secret key
<2> Pedersen commitments to coefficients
<3> Shares for _P~j~_ encrypted with the shared symkey

==== Phase 4: Share verification

Receive, decrypt and validate shares from other participants. If any share
fails to pass validation, broadcast a complaint by publishing the corresponding
ephemeral private key so others can validate the result.

[source, python]
----
# Receive:

[(encryptedShares_1, commitments_1),
 ...
 (encryptedShares_N, commitments_N)]

# Calculate:

(G_4, IA_3, DQ_3) = checkBroadcast(3, G_3)

complaints_Ai = []

for j in G_4:
  E_ji = encryptedShares_j[i]

  (s_ji, sg_ji) = decrypt(K_ij, E_ji)

  C_prod = product(
    for k in [0..T]:
      commitments_j[k] ^ (i^k)
  ) mod p

  if g^s_ji * h^sg_ji /= C_prod:
    complaints_i += X_ij # <<1>>

# Broadcast:

complaints_Ai
----

<<1>> Publish the private key _P~i~_ created for communicating with _P~j~_,
so anyone can decrypt and verify the shares _P~i~_ received from _P~j~_.

==== Phase 5: First complaint resolution

If anyone has complaints about another player,
use the published privkeys to decrypt transmitted messages and determine fault.
As every message in the broadcast channel is signed,
decrypting previous messages makes misbehavior attributable.
For every complaint, one party will be disqualified:
either the accused sent invalid shares,
or the accuser made a false complaint.

[source, python]
----
# Receive:

[complaints_A1, complaints_A2, ... ]

# Calculate:

(G_5, IA_4, DQ_4) = checkBroadcast(4, G_4)

DQ_5 = []

complaints_A = union(complaints_A1, complaints_A2, ...)

for c in complaints_A:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, sg_mj) = decrypt(K_jm, E_mj)

  C_prod = product(
    for k in [0..T]:
      C_jk ^ (m^k)
  ) mod p

  if g^s_mj * h^sg_mj = C_prod: # <1>
    DQ_5 += P_j
  else:
    DQ_5 += P_m
----

<<1>> If the shares are inconsistent with commitments,
disqualify the accused _P~m~_; if consistent, disqualify the accuser _P~j~_.


==== Phase 6: Share calculation

Each player sets their share _x~i~_ of the secret _X_ to equal the sum of all
shares _s~ji~_ as per GJKR. _X_ equals the sum of shares _s~j0~_.

[source, python]
----
# Calculate:

G_6 = G_5 - DQ_5

x_i = sum(
  for j in G_6:
    s_ji
) mod q

x'_i = sum(
  for j in G_6:
    sg_ji
) mod q
----


==== Phase 7: Public key share points

Each player broadcasts their _A~ik~_ values.

[source, python]
----
# Calculate:

G_7 = G_6

for k in [0..T]:
  A_ik = g^a_ik mod p

# Broadcast:

[A_i0, A_i1, ... A_iT]
----

==== Phase 8: Public key share validation

Each player validates the values received in the previous step.

[source, python]
----
# Receive:

[[A_10, A_11, ... A_1T], ...]

# Calculate:

(G_8, IA_7, DQ_7) = checkBroadcast(7, G_7)

complaints_Bi = []

for j in G_8:
  A_prod = product(
    for k in [0..T]:
      A_jk ^ (i^k)
  ) mod p

  if g^s_ji /= A_prod:
    complaints_B += X_ij

# Broadcast:

complaints_Bi
----

==== Phase 9: Second complaint resolution

As in Phase 5, but with the validation formula from Phase 8.

It should be noted that the symmetric nature of the encryption
allows the parties to also decrypt _E~jm~_ and not just _E~mj~_.
This is not very significant though,
as even the publication of only the misbehaving participantsg shares
would reduce the security margin excessively
if a large fraction of _G_ were to misbehave.
By setting the threshold for group creation failure at _f~max~/2_
the impact of this is reduced to a manageable level.

[source, python]
----
# Receive:

[complaints_B1, complaints_B2, ...]

# Calculate:

(G_9, IA_8, DQ_8) = checkBroadcast(8, G_8)

DQ_9 = []

complaints_B = union(complaints_B1, complaints_B2, ...)

for c in complaints_B:
  P_j = c.sender
  P_m = c.accused
  X_jm = c.revealedKey

  K_jm = ecdh(X_jm, Y_mj)

  (s_mj, sg_mj) = decrypt(K_jm, E_mj)

  A_prod = product(
    for k in [0..T]:
      A_mk ^ (j^k)
  ) mod p

  if g^s_mj = A_prod:
    DQ_9 += P_j
  else:
    DQ_9 += P_m
----

==== Phase 10: Disqualified share opening

All active players in _G~10~_ broadcast the keys they share with
players in _DQ~9~_, so the reconstruction of Pedersen-VSS can be done
offline.

[source, python]
----
# Calculate:

G_10 = G_9 - DQ_9

keys_i = []

for m in DQ_9:
  keys_i += X_im

# Broadcast:

if keys_i /= []:
  keys_i
----

==== Phase 11: Disqualified share reconstruction

Decrypt and reconstruct _z~m~_ for every participant _P~m~_ that presented
valid shares in _phase 4_ but whose public key shares in _phase 7_ were invalid.

[source, python]
----
# Receive:

[keys_1, keys_2, ... , keys_N]

# Calculate:

(G_11, IA_10, DQ_10) = checkBroadcast(10, G_10)

for m in (G_6 - G_11): # <1>
  for j in G':
    X_jm = keys_j[m]

    K_jm = ecdh(X_jm, Y_mj)

    (s_mj, sg_mj) = decrypt(K_jm, E_mj)

  ss_m = take(T + 1, [s_m1, ... , s_mN])

  is_m = [s.index for s in ss_m]

  z_m = sum(
    for k in is_m, s_mk in ss_m:
      a_mk = product(
        for l in is_m, l /= k:
          k / (k - l)
      )
      s_mk * a_mk
  )
----
<<1>> Reconstruct the shares of participants that became inactive
or were disqualified since _phase 6_

==== Phase 12: Public key reconstruction

Let _G~12~ = G~11~_

Combine _y~j~_ for all participants in _G~6~_ to reconstruct the public key for
the group.

[source, python]
----
# Calculate:

for j in G_6:
  y_j = A_j0 = g^z_j mod p

Y = product(
  for j in G_6:
    y_j
) mod p
----


==== Phase 13: Result publication

Let _IA = IA~1~ + IA~2~ + ... + IA~10~_

Let _DQ = DQ~1~ + DQ~2~ + ... + DQ~10~_

Player _P~1~_ is the participant designated to submit the result on-chain.
However, if _P~1~_ does not submit a transaction
within _t~dkg~_ blocks of starting the key generation protocol,
_P~2~_ becomes eligible to submit the public key.
After _t~dkg~ + t~step~_ blocks, _P~3~_ becomes eligible,
after _t~dkg~ + 2 * t~step~_ blocks _P~4~_, and so on.

When _P~j~_ submits the result, players _P~k~ | k < j_ will face a small
penalty for being late, while _P~j~_ will receive the submission reward.

[source, python]
----
if nPlayers(IA + DQ) > T/2:
  correctResult = Result.failure(disqualified = DQ)
else:
  correctResult = Result.success(pubkey = Y, inactive = IA, disqualified = DQ)

resultHash = hash(correctResult)

alreadySubmitted = False
resultPublished = False
finished = False

while not resultPublished:
  t_now = getCurrentBlockHeight()

  # using t_init from phase 1
  t_elapsed = t_now - t_init

  # determine highest index j eligible to submit
  if t_elapsed <= t_dkg:
    j = 1
  else:
    t_over = t_elapsed - t_dkg
    j = 1 + ceiling(t_over / t_step)

  if j >= i:
    broadcast(correctResult)
    resultPublished = True
    alreadySubmitted = True
  else:
    resultPublished = checkChainForResult()
----

==== Phase 14: Result conflict resolution

Because of the honest majority assumption, we can expect
a result supported by at least _f~max~ + 1_ participants to be correct.

If any participant disputes a result submitted on-chain, they can submit a
different one.

If any participant disputes the submitted result that currently has the greatest
number of signatures on-chain, believing a different result submitted on-chain
to be the correct one, they can publish a support message by publishing a
hash of their preferred result
(implicitly authenticated with the signature inherent in publishing on-chain).

Any participant can only vote for one submitted result, by submitting it or
publishing a support message for it.

Because of the available honest majority assumption, we can expect that any
result that is not at the lead after _t~conflict~_ time has elapsed has
acquired its maximum number of signatures it would be able to receive, and
thus the result receiving the plurality of support is the correct one.

An exception to this is if the total number of signatures supporting all other
submitted results is higher than _f~max~_, in which case the result is declared a
failure without disqualifications.

[source, python]
----
while resultPublished and not finished:
  allResults = getSubmissions()
  leadResult = allResults.mostVotes

  t_now = getCurrentBlockHeight()
  t_first = allResults.earliest.submitTime

  if t_now > t_first + t_conflict or leadResult.votes > f_max:
    finished = True

  elif correctResult = leadResult or alreadySubmitted:
    wait()

  elif correctResult in allResults:
    submit(sign(resultHash))
    alreadySubmitted = True

  else:
    submit(correctResult)
    alreadySubmitted = True
----

From the perspective of the chain:


[source, python]
----
# memberVotes :: Set PlayerID
memberVotes = Set.empty()

# receivedSubmissions :: Map (HashOf Result) Result
receivedSubmissions = Map.empty()

# submissionVotes :: Map (HashOf Result) Int
submissionVotes = Map.empty()


def eligibleSubmitter(P_i):
    t_now = getCurrentBlockHeight()
    t_elapsed = t_now - t_init

    i = P_i.index

    if i == 1:
        True
    elif t_elapsed >= t_dkg + (i-2) * t_step:
        True
    else:
        False


def addVote(player, resultHash):
    memberVotes.add(player)
    submissionVotes[resultHash] += 1


def alreadyVoted(player):
    memberVotes.contains(player)


def addSubmission(submitter, result):
    resultHash = hash(result)
    receivedSubmissions[resultHash] = result
    memberVotes.add(submitter)
    submissionVotes[resultHash] = 1


def alreadySubmitted(resultHash):
    receivedSubmissions.hasKey(resultHash)

# data Submission = Submission Result PlayerID
# data Vote = Vote (HashOf Result) PlayerID

def receiveSubmission(s):
    P_s = s.submitter
    result = s.result
    resultHash = hash(result)

    if receivedSubmissions == {}:
        if eligibleSubmitter(P_s): # <1>
            addSubmission(P_s, s)
        else:
            reject(s)
    else:
        if alreadyVoted(P_s):
            reject(s)
        elif alreadySubmitted(resultHash): # <2>
            addVote(P_s, resultHash)
        else:
            addSubmission(P_s, result)

def receiveVote(v):
    P_v = v.submitter
    resultHash = hash(v.result)

    if alreadyVoted(P_v) or not alreadySubmitted(resultHash):
        reject(v)
    else:
        addVote(P_v, resultHash)


def getFinalResult():
    (leadingResult, highestVoteN) = submissionVotes.maxByValue()
    totalVotes = sum(submissionVotes.values())

    if totalVotes - highestVoteN >= f_max: # <3>
        return Result.failure(disqualified = [])
    else:
        return leadingResult
----

<<1>> Eligibility gets tested on the first submission only;
after one valid submission it's a free for all.

<<2>> When the same result gets "initially" submitted,
such as when a different result was previously submitted and two
participants submit theirs in the same block

<<3>> If more than _f~max~_ participants vote for a non-leading result,
our honest majority assumption has failed
and we cannot determine the correct outcome.

[bibliography]
== References

- [[[GJKR]]] Gennaro R., Jarecki S., Krawczyk H., Rabin T. (1999)
Secure Distributed Key Generation for Discrete-Log Based Cryptosystems.
In: Stern J. (eds) Advances in Cryptology — EUROCRYPT ’99. EUROCRYPT 1999.
Lecture Notes in Computer Science, vol 1592. Springer, Berlin, Heidelberg

- [[[Ped]]] Pedersen T.P. (1992)
Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing.
In: Feigenbaum J. (eds) Advances in Cryptology — CRYPTO ’91. CRYPTO 1991.
Lecture Notes in Computer Science, vol 576. Springer, Berlin, Heidelberg
