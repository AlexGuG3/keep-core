= Random Beacon Signing

=== Terminology

`P1`:: The generator point for the BLS elliptic curve

`X_k`:: The group private key of `Group_k`

`Y_k`:: The group public key: `Y_k = P1 * X_k`

`Entry_e`:: The entry matching the entry identifier `e`

`Input_e`:: The input for generating the new entry:
`Entry_e = Input_e * X`

`x_i`:: The individual private key of `P_i`

`y_i`:: The individual public key of `P_i`: `y_i = P1 * x_i`

`Share_i`:: The signature share by `P_i`: `Share_i = Input_e * x_i`

`N`:: The number of members in a group

`H`:: The number of members required for a honest majority

=== Request submission

in _Block~k~_

includes _request~i~_

The requester has placed their bid in escrow, and the funds are locked up until
either:

- the next valid output is submitted, and the payment is distributed to the
members of the group that signed output
- the signing failure deadline is reached, and the payment is refunded due to
the selected group's failure to produce the output in time

=== Signing group selection

When a valid request has been received,
the beacon selects the signing group to produce the new entry.

The previous entry is hashed to produce the signing group selection seed.

`seed = keccak256(previousEntry)`

The signing group is selected by taking the value of the seed
modulo the number of currently active groups,
and selecting the corresponding active group:

`selectedGroup = seed % numberOfGroups()`

=== Signature generation

The selected group now has `relayEntryTimeout` blocks to submit the
signature to `previousEntry`.

==== Generating signature shares

Each member `P_i` in `selectedGroup` calculates
their signature share:
`Share_i = previousEntry * x_i`.

The generated shares are broadcast to the other members.
The broadcast message contains
the `Share_i` and the member index `i` of the sender `P_i`.

`Message = (Share_i, i)`

==== Verifying signature shares

When `P_i` receives a signature share `Share_j` broadcast by `P_j`,
the share can be verified by `blsVerify(Share_j, y_j, previousEntry)`.
If `Share_j` is valid,
`P_i` can use it for reconstructing the threshold signature.
If `Share_j` is invalid, `P_i` must not use it for reconstructing the entry.

==== Reconstructing the signature

Once `P_i` has received at least `blsThreshold` valid shares,
the entry can be reconstructed using Lagrange interpolation.

----
shares = validMessages.map(share)

indices = validMessages.map(index)

newEntry = lagrangeInterpolate(0, indices, shares)
----

=== Output submission

in _Block~T_siginit+T_output~_ +
where _1 <= T~output~ < T~signing_failure~(request~i~)_

Member _P~submitter~_ of _Group~i~_ submits
`newEntry = blsSign(previousEntry, X_i)`

The beacon verifies that the submitted entry
is a valid signature of the previous entry
for the selected group's public key:

`blsVerify(newEntry, previousEntry, Y_i)`

If the submitted entry is valid,
it is accepted as the current beacon entry _Entry~i~ = newEntry_.
Reward _P~submitter~_ and other members of _Group~i~_
according to the reward formula.

If the submitted entry is invalid, it is rejected.

=== Entry timeout

If a valid output _v~i~_ is not submitted before block
`timeoutBlock = currentEntryStartBlock + relayEntryTimeout + 1`,
the entry generation for the selected group times out.
From `timeoutBlock` onwards,
no submissions by _Group~i~_ are accepted,
and anyone can report the timeout by calling `reportRelayEntryTimeout()`.

When the beacon receives a valid timeout report
the previously selected group is terminated,
with each member penalized for their (lack of) contribution to the failure.
A new signing group is then selected to produce the entry.
