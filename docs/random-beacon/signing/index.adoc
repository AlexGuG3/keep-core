= Random Beacon Signing

=== Terminology

`P1`:: The generator point for the BLS elliptic curve

`X_k`:: The group private key of `Group_k`

`Y_k`:: The group public key: `Y_k = P1 * X_k`

`Entry_e`:: The entry matching the entry identifier `e`

`Input_e`:: The input for generating the new entry:
`Entry_e = Input_e * X`

`x_i`:: The individual private key of `P_i`

`y_i`:: The individual public key of `P_i`: `y_i = P1 * x_i`

`Share_i`:: The signature share by `P_i`: `Share_i = Input_e * x_i`

`N`:: The number of members in a group

`H`:: The number of members required for a honest majority

=== Request submission

in _Block~k~_

includes _request~i~_

The requester has placed their bid in escrow, and the funds are locked up until
either:

- the next valid output is submitted, and the payment is distributed to the
members of the group that signed output
- the signing failure deadline is reached, and the payment is refunded due to
the selected group's failure to produce the output in time

=== Signing group selection

in _Block~k+1~_

take hash of _Block~k+1~_, _rseed~i~ = blockHash(k+1)_

use _rseed~i~_ to select _Group~i~_ from _GG_

This value is locked in at _Block~k+1~_ but in actuality only calculated at the
seed reveal stage, because the blockchain cannot perform spontaneous operations.

=== Signature generation

_Group~i~_ now has _T~signing_failure~(request~i~)_ blocks to submit the
signature to _input~i~_.

If a valid output _v~i~_ is not submitted before
_Block~T_siginit+T_signing_failure(request_i)~_, the signing fails and the group
is terminated, with each member penalized for their (lack of) contribution to
the failure.

Because the blockchain cannot perform autonomous actions, this is done by having
anyone submit a signing failure transaction. Attempts to submit the output after
the failure deadline should be treated as signing failure transactions instead.
The signing failure transaction needs no specific content; it triggers the stake
slashing for the group members and refunds the output bid to the requester.

==== Generating signature shares

==== Verifying signature shares

When `P_j` creates a signature share `Share_j`
as a member of `Group_k`
producing a threshold signature for `Entry_e`
the share must be broadcast to the other members in a message containing:

* the signature share `Share_j`
* the member index `j` of the sender `P_j`;

When `P_i` receives a signature share `Share_j` broadcast by `P_j`,
the share can be verified by `blsVerify(Share_j, y_j, Input_e)`.
If `Share_j` is valid,
`P_i` can use it for reconstructing the threshold signature.
If `Share_j` is invalid, `P_i` must not use it for reconstructing the entry.

==== Reconstructing the signature

=== Output submission

in _Block~T_siginit+T_output~_ +
where _1 <= T~output~ < T~signing_failure~(request~i~)_

_input~i~ = H(seed~i~, rseed~i~, v~i-1~)_

member _P~submitter~_ of _Group~i~_ submits _v'~i~ = blsSign(input~i~, pk~G~)_

verify signature

if valid, _blsVerify(v'~i~, input~i~, Y~G_i~) == True_:

- reward _P~submitter~_ by
_R~submitter~(T~output~) * RequestMultiplier~i~_
- reward _P~o~!= P~submitter~_ of _Group~i~_ by
_R~group~(T~output~) * RequestMultiplier~i~_
- set the beacon output as _v~i~ = v'~i~_

if invalid:

- punish _P~n~_ by _D~INVALID_SIGNATURE~ * RequestMultiplier~i~_

If _T~output~ > T~signing_deadline~(request~i~)_, the other members of
_Group~i~_ apart from _P~submitter~_ will be penalized for a late output.

////
==== Output share submission

If reward anchoring is used, members of _Group~i~_ can also submit signature
shares to anchor their reward to _T~share~_, an earlier moment than the final
submission of the output.

An output share can be submitted by any member _P~n~_ of _Group~i~_, if a valid
output _v~i~_ has not been submitted yet. The submission should contain:

- the individual public key of _P~n~_: _gx~n~ = P1 * x~n~_
- the signature share: _blsSign(input~i~, x~n~)_
- the merkle path from _gx~n~_ to the merkle root of _Group~i~_

The signature share is verified like the output submission would be, but using
_gx~n~_ instead of _Y~i~_. Additionally, the merkle path of _gx~n~_ is verified.

If the share is valid, _P~n~_ should be rewarded by _R~group~(T~share~)_.

If the share is invalid, _P~n~_ should be punished as if they had submitted an
invalid output.
////
