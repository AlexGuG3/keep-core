= Random Beacon Signing

=== Terminology

`P1`:: The generator point for the BLS elliptic curve

`X_k`:: The group private key of `Group_k`

`Y_k`:: The group public key: `Y_k = P1 * X_k`

`Entry_e`:: The entry matching the entry identifier `e`

`Input_e`:: The input for generating the new entry:
`Entry_e = Input_e * X`

`x_i`:: The individual private key of `P_i`

`y_i`:: The individual public key of `P_i`: `y_i = P1 * x_i`

`Share_i`:: The signature share by `P_i`: `Share_i = Input_e * x_i`

`N`:: The number of members in a group

`H`:: The number of members required for a honest majority

=== Request submission

in _Block~k~_

includes _request~i~_

The requester has placed their bid in escrow, and the funds are locked up until
either:

- the next valid output is submitted, and the payment is distributed to the
members of the group that signed output
- the signing failure deadline is reached, and the payment is refunded due to
the selected group's failure to produce the output in time

=== Signing group selection

When a valid request has been received,
the beacon selects the signing group to produce the new entry.

The previous entry is hashed to produce the signing group selection seed.

`seed = keccak256(previousEntry)`

The signing group is selected by taking the value of the seed
modulo the number of currently active groups,
and selecting the corresponding active group:

`selectedGroup = seed % numberOfGroups()`

=== Signature generation

The selected group now has `relayEntryTimeout` blocks to submit the
signature to `previousEntry`.

==== Generating signature shares

Each member `P_i` in `selectedGroup` calculates
their signature share:
`Share_i = previousEntry * x_i`.

The generated shares are broadcast to the other members.
The broadcast message contains
the `Share_i` and the member index `i` of the sender `P_i`.

`Message = (Share_i, i)`

==== Verifying signature shares

When `P_i` receives a signature share `Share_j` broadcast by `P_j`,
the share can be verified by `blsVerify(Share_j, y_j, previousEntry)`.
If `Share_j` is valid,
`P_i` can use it for reconstructing the threshold signature.
If `Share_j` is invalid, `P_i` must not use it for reconstructing the entry.

==== Reconstructing the signature

Once `P_i` has received at least `blsThreshold` valid shares,
the entry can be reconstructed using Lagrange interpolation.

----
shares = validMessages.map(share)

indices = validMessages.map(index)

newEntry = lagrangeInterpolate(0, indices, shares)
----

=== Output submission

in _Block~T_siginit+T_output~_ +
where _1 <= T~output~ < T~signing_failure~(request~i~)_

_input~i~ = H(seed~i~, rseed~i~, v~i-1~)_

member _P~submitter~_ of _Group~i~_ submits _v'~i~ = blsSign(input~i~, pk~G~)_

verify signature

if valid, _blsVerify(v'~i~, input~i~, Y~G_i~) == True_:

- reward _P~submitter~_ by
_R~submitter~(T~output~) * RequestMultiplier~i~_
- reward _P~o~!= P~submitter~_ of _Group~i~_ by
_R~group~(T~output~) * RequestMultiplier~i~_
- set the beacon output as _v~i~ = v'~i~_

if invalid:

- punish _P~n~_ by _D~INVALID_SIGNATURE~ * RequestMultiplier~i~_

If _T~output~ > T~signing_deadline~(request~i~)_, the other members of
_Group~i~_ apart from _P~submitter~_ will be penalized for a late output.

=== Entry timeout

If a valid output _v~i~_ is not submitted before block
`timeoutBlock = currentEntryStartBlock + relayEntryTimeout + 1`,
the entry generation for the selected group times out.
From `timeoutBlock` onwards,
no submissions by _Group~i~_ are accepted,
and anyone can report the timeout by calling `reportRelayEntryTimeout()`.

When the beacon receives a valid timeout report
the previously selected group is terminated,
with each member penalized for their (lack of) contribution to the failure.
A new signing group is then selected to produce the entry.
