:icons: font
:numbered:
toc::[]

== Contract structure

Contracts in the Keep Network are divided into categories
based on their roles, functionality and security implications.
The contract structure is designed to permit upgrading any components
while protecting stakers and customers.

==== Contract types

Token contract::

KEEP is an ERC20 token defined by the _token contract_.
The token contract is hard-coded in the operator and staking contracts,
but the design of the overall system makes it possible
to later migrate to a new version of the token contract
without disrupting customer experience.

Staking contract::

Owners of KEEP tokens can use a _staking contract_
to _stake_ them and use them as collateral for _operators_
who perform useful work in the Keep Network.
Staked tokens are transferred to the staking contract
and _delegated_ to an operator address.
The staking contract makes the tokens available to _operator contracts_
that have been _authorized_ to punish the operator in case of misbehavior,
while protecting them from unauthorized operator contracts.

Operator contracts::

Operators interact with _operator contracts_
to perform useful work for customers.
Operator contracts handle operations
that are critical for the proper incentives of individual operators.
They reward operators for correct behavior,
and are authorized to punish misbehavior.

Service contracts::

_Service contracts_ provide higher-level services to the public
using work performed by one or more operator contracts.
Service contracts do not interact directly with operators
nor do they need to be aware of the KEEP tokens or the staking contract.
Operator contracts can be upgraded without disrupting customer experience
by deploying a new version and adding it to the service contract.

Registry::

The addresses of contracts approved by Keep Org are kept in the _registry_.
Token contracts, staking contracts, operator contracts and service contracts
are all tracked separately in the registry.
The addresses and statuses of various contracts
can be queried from the registry.

== Background

Stakers in the Keep network use _work contracts_ to perform work for customers. Work contracts make the off-chain work of stakers available to on-chain applications using a system of rewards and punishments to enforce correct behavior.

Because work contracts must be able to penalize misbehaving stakers by slashing their staked tokens, it is important that they can be upgraded securely. For an upgrade to be considered secure, two things must be achieved:

1. stakers must authorize any contracts that could slash their stakes
2. once authorized, contract code must be immutable

Condition 1 is important to protect stakers against errors and adversaries. Upon staking their tokens, each staker appoints an authorizer who must approve of all contracts that could punish the staker. This ensures that stakes cannot be stolen even if the work contract upgrade scheme is thoroughly compromised, as long as the individual authorizers reject bad work contracts.

Condition 2 is a practical requirement to make condition 1 meaningful. If an authorized contract's code can be changed later, the authorizations provide no protection. This means that contracts can only be upgraded by deploying a new version,
which the stakers then authorize individually.

However, deploying a new contract on every upgrade makes migrating between implementations difficult. Common ways of upgrading contracts, such as the "eternal storage" pattern where the contract holds data in its nominal address while delegating logic to a different, upgradeable contract address, are incompatible with individual upgrade authorization.

=== Current Functionality

The current design for upgrading work contracts is to deploy a new version on every upgrade, and wait for stakers to start operating on it. Older versions would by necessity keep existing in parallel with newer ones, and migrating state between versions is difficult if not impossible. For example, different versions of threshold BLS contracts, even if the changes are as minor as adjusting hardcoded constants, would create entirely separate random beacons. It is possible that the difficulty of migration would lead customers to prefer the old version with established state.

=== Implementation

For each service provided on the Keep network, the components critical for correct incentives are identified and separated from the rest of the service contract as a _operator contract_. Operator contracts aim to be self-contained incentive-wise,
minimizing or eliminating the need for stakers to trust other contracts.

Customer applications use a _service contract_ to perform work. The _service contract_ provides a unified interface to customers, handling the version management of _operator contracts_ and any shared non-critical state between them.

==== Operator contracts

Operator contracts coordinate the work performed by network operators,
and provide services to other "customer" contracts.
Operator contracts handle all operations
that may have an impact on staked tokens.
Conversely, operators performing work for the network
only need to interact with operator contracts.

The customer contract is treated as untrusted
and the operator contract must maintain correctness
and the safety of the operators' stakes
regardless of the customer contract's input.
Each operator contract is an independent "microservice",
keeping its own state on security-critical data.

When a customer contract requests an operator contract to perform a service,
it must pay the operator contract for the service provided.
The payment is distributed to contributing operators
according to the operator contract's own rules.
An operator contract can either provide services
to any contract that makes a valid request and pays the correct fee,
or it can be owned is owned by a specific contract and only serve its owner.
In the random beacon
the service contract is the only "customer" of the operator contracts,
and operator contracts only provide services to the random beacon.
Future operator contracts may provide services directly to the public.

If one or more participant operators misbehave
or fail to perform promised work,
the operator contract tells the staking contract to punish the guilty parties
and optionally reward a tattletale that proved the misbehavior.
To punish misbehaving operators,
an operator contract must be authorized by the operator's authorizer.
Once an operator contract has been authorized by some address,
it can never be deauthorized by that address.

==== Service contracts

Service contracts use the basic functionality
performed by operator contracts,
to provide useful services to the public.
In contrast to operator contracts,
service contracts don't interact directly with operators
and a failure in a service contract cannot risk operators' stakes.

Service contracts receive requests for their services from customers,
and provide the requested services.
Elements that are critical for operators' security and incentives
are delegated to an operator contract,
while other parts of the work are performed in the service contract.
The service contract keeps shared state which is not security-critical.

Service contracts can use
multiple different versions of operator contracts
to perform the operator contract functions.
To permit system upgrades,
the list of used operator contracts can be updated with proper authorization.

==== Security-critical service contracts

In some situations it may not be possible to contain critical code entirely within the operator contract. If the service contract has to provide trusted input that may impact operators' stakes, the opt-in stake security can be maintained if the service contract is immutable and upgrades are performed by deploying new operator contracts.

In these situations care should be taken to ensure that operator contracts cannot interfere with each other. As a general rule, state shared between different operator contracts should not be used to impact stakes.

If a customer application provides the trusted input, operators should have a method to opt in to only serving those applications they have audited and found acceptable.

=== Example: Random Beacon

The random beacon generates random numbers in response to requests, using BLS threshold signatures on some specific input. The signatures are generated by signing groups that have been created using random sortition from all eligible and active stakers. Rewards and punishments are used to incentivize correct behavior.

To split the random beacon into a service contract-operator contract design, the security-critical elements need to be identified.

In this case the operator contract needs to handle group creation and expiration, BLS signature verification, and incentives.

Handling entry requests and pricing; determining the signing input for generating new entries; calling callbacks; and requesting the creation of new groups are responsibilities that are not critical for beacon integrity from the perspective of the stakers. These can be performed by the service contract without individual staker authorization of upgrades.

==== Operator contract
TODO: Any reason this section is separate from the section named the same above? Can they be combined?
The operator contract for the random beacon provides the following interface to the service contract:

`create_group(payment)`:Create a new group when requested by the service contract,
selecting members using pseudorandom sortition, and performing DKG. The operator contract does not accept input from the service contract, but instead uses its own pseudorandom seed, to ensure that group composition cannot be manipulated. `payment` must exceed a minimum amount and is used to cover gas fees and to reward stakers.

`sign(entry_id, group_input, signing_input, payment)`:Use `group_input` to select a signing group, and generate a valid BLS threshold signature for `signing_input`. Once generated, use `payment` to reward stakers. `payment` must exceed a set minimum value that covers necessary gas fees. When the entry is created, the operator contract calls the service contract with the new entry, using `entry_id` to identify the entry.

Behind this interface,the operator contract tracks its own groups, their members and their threshold public keys. The service contract trusts the operator contract to only provide valid entries when given specific inputs. Alternatively the operator contract could provide the associated public key so the entry can be validated, but even then the operator contract needs to be trusted to provide a public key corresponding to a random valid group.

==== Service contract

The service contract for the random beacon handles customer-facing features and ties the operator contracts together. The interface of the service contract towards the operator contract is:

`group_created(n_groups)`: The call to `create_group()` has finished (successfully or unsuccessfully) and expired groups have been removed. The operator contract now has `n_groups` active.

`entry_created(entry_id, entry)`: The previous call for the operator contract to `sign(entry_id, ...)` completed successfully, resulting in the new `entry`. The service contract keeps a list of operator contracts along with the number of active groups in each.

When receiving a request, the service contract determines what values should be the group selection input and the signing input. The group selection input is used to select an operator contract, weighted by the number of active groups on each, to serve the request.

When the operator contract is determined, the group selection input and signing input are passed to it along with an appropriate payment. When the operator contract returns a valid entry with `entry_created(...)`, the service contract stores it and calls the customer-specified callback.

If a new group should be created, the service contract determines which operator contract should create one (the most recent one, or a random one weighted by recent-ness), and calls `create_group()` on the selected operator contract with an appropriate payment. Once the operator contract has finished DKG and expired old groups,it returns the new number of active groups using `group_created(n_groups)`.

Unlike the operator contract which needs to maintain integrity for arbitrary, malicious inputs, the service contract relies heavily on trusting the operator contracts. This is acceptable because the operator contracts are known, unchangeable code, and the service contract only has access to what customers have paid for entries; boycotting a compromised or malfunctioning service contract and deploying a new one is sufficient to mitigate attacks or errors.


[bibliography]
