:toc: macro
:icons: font

= Keep ECDSA v2

The Keep Network offers threshold ECDSA protocol to generate a ECDSA wallets
without any single signer having access to the corresponding private key. This
functionality is used by TBTC v2 to manage Bitcoin wallets used by TBTC Bridge.

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

toc::[]

== Overview

Keep ECDSA allows creating threshold ECDSA wallets where where `n` parties share
the power to issue digital signatures under a single public key. A threshold `t`
is specified such that any subset of `t + 1` players can jointly sign, but any
smaller subset cannot.

`WalletRegistry` smart contract is an on-chain registry of ECDSA wallets
controlled by off-chain network of nodes. The distributed key generation
protocol used by the off-chain network of nodes should have three properties:

- The signing group as a whole should have an ECDSA public key, which will be
  shared on the host chain (Ethereum) and will correspond to the Bitcoin wallet
  owned by that signing group.
- Each member of the signing group should have a threshold ECDSA secret key
  share, which can be used to create a threshold ECDSA signature share for any
  transactions involving the signing groupâ€™s wallet.
- Each member of the signing group should be able to combine a threshold number
  of signature shares from itself and other members of the group to produce a
  signed version of a given transaction to be performed on behalf of the signing
  group.

== Prior Work

Smart contract for the first version of Keep ECDSA ara available in
link:https://github.com/keep-network/keep-ecdsa/tree/main/solidity[`keep-ecdsa` repository].
The new version is optimised for larger groups by implementing optimistic
sortition during DKG protocol. Staker rewards are redesigned and allocated for
all sortition pool members. Most parameters are now governable.

== The Mechanism

=== Wallet Creation

New wallet is created on request from wallet owner address. Signing group
creation starts with an owner's call to `WalletRegistry.requestNewWallet()`.
This transaction locks the sortition pool and sends a request to the Random
Beacon for a new relay entry. From this moment, no operator can enter
or leave the pool. Once a new relay entry appears on the chain, all off-chain
clients perform group selection by calling `WalletRegistry.selectGroup()` view
function for free. Relay entry provided by the Random Beacon is used as a seed
for the group selection. After determining signing group members, clients should 
perform off-chain distributed key generation (DKG).
<<operator-only,One of the group members>> submits the result to the chain
calling `WalletRegistry.submitDkgResult(DKG.Result calldata dkgResult)`
function. Once the result is submitted, a challenge period starts.

During the challenge period, anyone can notify that the submitted DKG result is
malicious by calling `WalletRegistry.challengeDkgResult(DKG.Result calldata dkgResult)`
function. A malicious DKG result may contain corrupted data, group members not
selected by the pool, or incorrect supporting signatures. If such malicious
result is submitted and successfully challenged, the result submitter gets
slashed and the malicious result is immediately discarded. The address which
notified about malicious DKG result is <<punishment,rewarded>>. DKG timeout
timer is reset, and group members have another chance to submit a valid result.

Once the challenge period passes, and no valid challenge is reported, the DKG
result submitter should unlock the sortition pool and mark the DKG result as
approved calling `WalletRegistry.approveDkgResult(DKG.Result calldata dkgResult)`.
The submitter receives an ETH reimbursement for both `submitDkgResult` and
`approveDkgResult` transaction as described in
<<transaction-incentives,Transaction Incentives>> section. In case the original
submitter does not call the `approveDkgResult` function within a specific number
of blocks, anyone can do that and receive the submitter's reimbursement.

There is a timeout before which a DKG result should be submitted.
In case the DKG result was not submitted before a timeout, anyone can notify DKG
timed out by calling `WalletRegistry.notifyDkgTimeout()` and unlock the sortition
pool. In case the relay entry was not produced by the random beacon on time,
anyone can notify a seed timeout by calling `WalletRegistry.notifySeedTimeout()`
and unlock the sortition pool.

Off-chain clients are expected to follow the <<operator-only,submission order>>
when submitting DKG result to avoid front-running and minimize the cost, but no
ordering is enforced on-chain.

The sortition pool weights operators by their authorized stake amount and allows
selecting the same operator multiple times. Inactive/disqualified members during
the off-chain DKG protocol are marked as ineligible for <<rewards,rewards>> for
a governable period of time when the DKG result is approved.

Each ECDSA wallet created in the system remains active until it is closed
by the wallet owner with a call to `WalletRegistry.closeWallet()`.

== Build

The contracts use https://hardhat.org/[*Hardhat*] development
environment. To build and deploy contracts, please follow the instructions
presented below.

=== Prerequisites

Please make sure you have the following prerequisites installed on your machine:

- https://nodejs.org[Node.js] >=14
- https://yarnpkg.com[Yarn] >=1.22

=== Build contracts

To build the smart contracts, install node packages first:

```sh
yarn install
```

Once packages are installed, you can build the smart contracts using:

```sh
yarn build
```

Compiled contracts will land in the `build/` directory.

==== TypeScript Typings

Typings are generated for the contracts in `typechain/` directory.

=== Test contracts

There are multiple test scenarios living in the `test` directory.
You can run them by doing:

```sh
yarn test
```

=== Deploy contracts

To deploy contract execute:

```
yarn deploy --network <NETWORK>
```

After the Bridge contract from tbtc-v2 is deployed it has to be set as the
Wallet Owner in the `WalletRegistry`:

```
npx hardhat --network <NETWORK> initialize-wallet-owner --wallet-owner-address <BRIDGE_ADDRESS>
```
