= Keep Random Beacon v2

The Keep Network requires a trusted source of randomness for the process of
trustless group election. While the network requires that randomness to function
correctly, the source of randomness is itself broadly applicable. This trusted
source of randomness takes the form of a BLS Threshold Relay.

== Overview

The threshold relay is a way of generating verifiable randomness that is
resistant to bad actors both in the relay network and on the anchoring Ethereum
blockchain. The basic functioning of the relay is:

- Some number of groups exist in the relay.
- An arbitrary seed value `v_s` counts as the first entry in the relay.
- A request `r_i` is dispatched to the chain for a new entry.
- The previous entry `v_s` is used to choose a group to produce the response to
  the request.
- `v_s` is signed by at least a subset of the chosen group members, and the
  resulting signature is the entry generated in response to the request. It is
  published to the anchoring blockchain as the entry `v_i`.
- The new entry `v_i` may trigger the formation of a new group from the set of
  all members in the relay.
- A group expires after a certain amount of time.

== Prior Work

Smart contracts for the first version of the random beacon are available in
link:./../../solidity-v1[`solidity-v1` directory]. The new version uses the same
approach for BLS signatures as v1 but replaces ticket-based group selection with
an optimistic sortition pool call. It also redesigns staker rewards and offers
a more operator-friendly approach for relay entry timeouts. Last but not least,
most parameters for the relay are now governable. 

== The Mechanism

=== Group Creation

New groups are created with a fixed, governable frequency of relay requests.
Instead of a v1 ticket-based approach for group selection, we use sortition
pool. Group creation start transaction is embedded into relay request
transaction and locks a sortition pool. From this moment, no operator can enter
or leave the pool. Once a new relay entry appears on the chain, all off-chain
clients perform group selection optimistically calling
`RandomBeacon.selectGroup(seed)` view function for free. Seed is available in
`DkgStarted` event emitted when the group creation starts. After determining
group members, clients should perform off-chain distributed key generation (DKG).
Selected group member submits the result to the chain calling
`RandomBeacon.submitDkgResult(DKG.Result calldata dkgResult)` function. Once the
result is submitted, a challenge period starts.

During the challenge period, anyone can notify that the submitted DKG result is
malicious calling `RandomBeacon.challengeDkgResult(DKG.Result calldata dkgResult)`
function. Malicious DKG result may contain corrupted data, group members not
selected by the pool, or incorrect supporting signatures. If such malicious
result is submitted and challenged, the result submitter gets slashed and the
malicious result is immediately discarded. The length of the challenge period
and slashing amount are governable parameters.

Once the challenge period passes, DKG result submitter should unlock the
sortition pool and mark the DKG result as accepted calling
`RandomBeacon.approveDkgResult(DKG.Result calldata dkgResult)` to receive a
reward. In case the submitter does not call the approve function within a
specific number of blocks (governable value), anyone can do that and receive the
submitter's reward as described in Fees and Rewards section.

There is a timeout before which DKG result should be submitted. The timeout
equals the group size multiplied by the number of blocks for a member to become
eligible to submit DKG result. The timer starts at the moment when the first
member becomes eligible.

In case the DKG result was not submitted before a timeout, anyone can notify DKG
timed out calling `RandomBeacon.notifyDkgTimeout()` and receive a reward, as
described in Fees and Rewards section. DKG timeout includes the situation when
no new relay entry was produced and sortition could not be performed.

The sortition pool weights operators by their authorized stake amount and allows
selecting the same operator multiple times. Off-chain DKG protocol executes in
the same way as for v1 and inactive/disqualified members during the off-chain
protocol are marked as ineligible for rewards for a certain, governable, period
of time when DKG result is approved.

Each group created in the system remains active for a certain, governable period
of time. Group that expired is no longer selected for any new work and group is
handled in the relay request transaction.

=== Relay Request and Relay Entry

Anyone can request for a new relay entry (random number) calling
`RandomBeacon.requestRelayEntry(IRandomBeaconConsumer callbackContract)`
function and providing an optional callback parameter. The requester needs to
approve enough tokens for a fee, as described in Fees and Rewards section.
In `requestRelayEntry` transaction, groups that reached their maximum lifetime
are getting expired and one of the remaining active groups is tasked with
producing a new relay entry. All off-chain clients are expected to react to
`RelayEntryRequested` event and check if a group they are a member of has been
tasked with producing a new relay entry. If so, they should start off-chain
protocol to sign the previous relay entry producing a new relay entry this way.
Off-chain clients are expected to follow the order when submitting relay entry
to minimize and distribute costs evenly, as described in Fees and Rewards
section but no ordering is enforced on-chain. New relay entry should be
submitted using 
`RandomBeaocn.submitRelayEntry(uint256 submitterIndex, bytes calldata entry)`
function.

== Build

Random beacon contracts use https://hardhat.org/[*Hardhat*] development
environment. To build and deploy these contracts, please follow the instructions
presented below.

=== Prerequisites

Please make sure you have the following prerequisites installed on your machine:

- https://nodejs.org[Node.js] >12.22.1
- https://yarnpkg.com[Yarn] >1.22.10

=== Build contracts

To build the smart contracts, install node packages first:
```
yarn install
```
Once packages are installed, you can build the smart contracts using:
```
yarn build
```
Compiled contracts will land in the `build/` directory.

=== Test contracts

There are multiple test scenarios living in the `test` directory.
You can run them by doing:
```
yarn test
```