package config

import (
	"fmt"
	"strings"
	"syscall"

	"github.com/ipfs/go-log"
	"github.com/keep-network/keep-common/pkg/chain/ethereum"
	ethereumCommon "github.com/keep-network/keep-common/pkg/chain/ethereum"
	"github.com/keep-network/keep-core/pkg/beacon/registry"
	ethereumChain "github.com/keep-network/keep-core/pkg/chain/ethereum"
	ethereumBeaconGen "github.com/keep-network/keep-core/pkg/chain/ethereum/beacon/gen"
	"github.com/keep-network/keep-core/pkg/net/libp2p"
	"github.com/mitchellh/mapstructure"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"golang.org/x/crypto/ssh/terminal"
)

var logger = log.Logger("keep-config")

// Environment variables names for properties configuration. For simplification we
// bind the names that are different from the auto-generated by viper with the
// `viper.AutomaticEnv()` function. For example instead of expecting
// `KEEP_ETHEREUM_ACCOUNT_KEYFILEPASSWORD` we expect `KEEP_ETHEREUM_PASSWORD`.
const (
	// Environment Variables
	// #nosec G101 (look for hardcoded credentials)
	// This line doesn't contain any credentials.
	// It's just the name of the environment variable.
	ethereumPasswordEnvVariable = "KEEP_ETHEREUM_PASSWORD"

	configFilePathFlag = "config"

	// Command Line Flags
	dataDirFlag                 = "datadir"
	ethereumKeyFlag             = "ethereum.key"
	ethereumUrlFlag             = "ethereum.url"
	ethereumContractsPrefixFlag = "ethereum.contracts"
	portFlag                    = "network.port"
	peersFlag                   = "network.peers"
	announcedAddressesFlag      = "network.announced-addresses"
)

// Config is the top level config structure.
type Config struct {
	Ethereum    ethereumCommon.Config
	LibP2P      libp2p.Config `mapstructure:"Network"`
	Storage     Storage
	Metrics     Metrics
	Diagnostics Diagnostics
}

// Storage stores meta-info about keeping data on disk
type Storage struct {
	DataDir string
}

// Metrics stores meta-info about metrics.
type Metrics struct {
	Port                int
	NetworkMetricsTick  int
	EthereumMetricsTick int
}

// Diagnostics stores diagnostics-related configuration.
type Diagnostics struct {
	Port int
}

func init() {
	initEnvVars()
}

// initEnvVars initializes environment variables for the client configuration.
func initEnvVars() {
	if err := viper.BindEnv("ethereum.account.keyfilepassword", ethereumPasswordEnvVariable); err != nil {
		logger.Fatal(err)
	}
}

// InitFlags initializes command-line flags for the client configuration.
func InitFlags(command *cobra.Command) {
	command.PersistentFlags().StringP(
		configFilePathFlag,
		"c",
		"",
		"path to the configuration file",
	)

	command.Flags().String(ethereumKeyFlag, "", "operator's Ethereum Key File path")
	viper.BindPFlag("ethereum.account.keyfile", command.Flags().Lookup(ethereumKeyFlag))

	command.Flags().String(ethereumUrlFlag, "", "Ethereum API URL")
	viper.BindPFlag("ethereum.url", command.Flags().Lookup(ethereumUrlFlag))

	command.Flags().String(dataDirFlag, registry.DefaultStoragePath, "path to the storage directory")
	viper.BindPFlag("storage.datadir", command.Flags().Lookup(dataDirFlag))

	command.Flags().IntP(portFlag, "p", libp2p.DefaultPort, "port at which client will be exposed")
	viper.BindPFlag("network.port", command.Flags().Lookup(portFlag))

	// TODO: Read default peers from a file.
	command.Flags().StringSlice(peersFlag, []string{}, "peers")
	viper.BindPFlag("network.peers", command.Flags().Lookup(peersFlag))

	command.Flags().StringSlice(announcedAddressesFlag, []string{}, "announced addresses")
	viper.BindPFlag("network.announcedaddresses", command.Flags().Lookup(announcedAddressesFlag))

	// Configure default contract addresses.
	bindEthereumContract := func(contractName string, defaultAddress string) (err error) {
		flag := fmt.Sprintf(
			"%s.%s",
			ethereumContractsPrefixFlag,
			strings.ToLower(contractName),
		)
		configKey := fmt.Sprintf("Ethereum.ContractAddresses.%s", contractName)

		command.Flags().String(
			flag,
			defaultAddress,
			fmt.Sprintf(
				"address of the %s contract",
				contractName,
			),
		)
		viper.BindPFlag(configKey, command.Flags().Lookup(flag))

		return
	}
	if err := bindEthereumContract(
		ethereumChain.RandomBeaconContractName,
		ethereumBeaconGen.RandomBeaconAddress,
	); err != nil {
		logger.Fatal(err)
	}
}

// ReadConfig reads in the configuration file at `filePath` and returns the
// valid config stored there, or an error if something fails while reading the
// file or the config is invalid in a known way.
func ReadConfig(configFilePath string) (*Config, error) {
	// Read configuration from a file if the config file path is set.
	if configFilePath != "" {
		if err := readConfigFile(configFilePath); err != nil {
			return nil, fmt.Errorf("unable to load config (file: [%s]): [%w]", configFilePath, err)
		}
	}

	// Unmarshal config based on loaded config file and command-line flags.
	config := &Config{}
	if err := unmarshalConfig(config); err != nil {
		return nil, fmt.Errorf("unable to unmarshal config: %w", err)
	}

	if config.Ethereum.Account.KeyFile == "" {
		return nil, fmt.Errorf("missing value for ethereum key file")
	}

	if config.LibP2P.Port == 0 {
		return nil, fmt.Errorf(
			fmt.Sprintf(
				"missing value for port; see network section in config file or use --%s flag",
				portFlag,
			),
		)
	}

	if config.Storage.DataDir == "" {
		return nil, fmt.Errorf(
			fmt.Sprintf(
				"missing value for storage directory; see storage section in config file or use --%s flag",
				dataDirFlag,
			),
		)
	}

	if strings.TrimSpace(config.Ethereum.Account.KeyFilePassword) == "" {
		var (
			password string
			err      error
		)
		fmt.Printf(
			"Ethereum Account Password has to be set for the configured Ethereum Key File.\n"+
				"Please set %s environment variable, or set it in the config file, or provide it in the prompt below.\n",
			ethereumPasswordEnvVariable,
		)

		for strings.TrimSpace(password) == "" {
			if password, err = readPassword("Enter Ethereum Account Password: "); err != nil {
				return nil, err
			}
		}

		config.Ethereum.Account.KeyFilePassword = password
	}

	return config, nil
}

// ReadEthereumConfig reads in the configuration file at `filePath` and returns
// its contained Ethereum config, or an error if something fails while reading
// the file.
//
// This is the same as invoking ReadConfig and reading the Ethereum property
// from the returned config, but is available for external functions that expect
// to interact solely with Ethereum and are therefore independent of the rest of
// the config structure.
func ReadEthereumConfig(filePath string) (ethereum.Config, error) {
	config, err := ReadConfig(filePath)
	if err != nil {
		return ethereum.Config{}, err
	}

	return config.Ethereum, nil
}

// readConfigFile uses viper to read configuration from a config file. The config file
// is not mandatory, if the path is
func readConfigFile(configFilePath string) error {
	// Read configuration from a file, located in `configFilePath`.
	viper.SetConfigFile(configFilePath)

	// Read configuration.
	if err := viper.ReadInConfig(); err != nil {
		return fmt.Errorf(
			"failed to read configuration from file [%s]: %w",
			configFilePath,
			err,
		)
	}

	return nil
}

// unmarshalConfig unmarshals config with viper from config file and command-line
// flags into a struct.
func unmarshalConfig(config *Config) error {
	if err := viper.Unmarshal(
		&config,
		viper.DecodeHook(
			mapstructure.ComposeDecodeHookFunc(
				mapstructure.StringToTimeDurationHookFunc(),
				mapstructure.StringToSliceHookFunc(","),
				mapstructure.TextUnmarshallerHookFunc(),
			),
		),
	); err != nil {
		return fmt.Errorf("failed to unmarshal configuration: %w", err)
	}

	return nil
}

// readPassword prompts a user to enter a password. The read password uses
// the system password reading call that helps to prevent key loggers from
// capturing the password.
func readPassword(prompt string) (string, error) {
	fmt.Print(prompt)
	bytePassword, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Print("\n")
	if err != nil {
		return "", fmt.Errorf("unable to read password, error [%s]", err)
	}

	return strings.TrimSpace(string(bytePassword)), nil
}
