package config

import (
	"fmt"
	"strings"
	"syscall"

	"github.com/ipfs/go-log"
	"github.com/keep-network/keep-common/pkg/chain/ethereum"
	ethereumCommon "github.com/keep-network/keep-common/pkg/chain/ethereum"
	"github.com/keep-network/keep-core/pkg/beacon/registry"
	ethereumChain "github.com/keep-network/keep-core/pkg/chain/ethereum"
	ethereumBeaconGen "github.com/keep-network/keep-core/pkg/chain/ethereum/beacon/gen"
	"github.com/keep-network/keep-core/pkg/net/libp2p"
	"github.com/mitchellh/mapstructure"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"golang.org/x/crypto/ssh/terminal"
)

var logger = log.Logger("keep-config")

// Environment variables names for properties configuration. For simplification we
// bind the names that are different from the auto-generated by viper with the
// `viper.AutomaticEnv()` function. For example instead of expecting
// `KEEP_ETHEREUM_ACCOUNT_KEYFILEPASSWORD` we expect `KEEP_ETHEREUM_PASSWORD`.
const (
	// Environment Variables
	// #nosec G101 (look for hardcoded credentials)
	// This line doesn't contain any credentials.
	// It's just the name of the environment variable.
	EthereumPasswordEnvVariable = "KEEP_ETHEREUM_PASSWORD"

	LogLevelEnvVariable = "LOG_LEVEL"
)

// Config is the top level config structure.
type Config struct {
	Ethereum    ethereumCommon.Config
	LibP2P      libp2p.Config `mapstructure:"Network"`
	Storage     Storage
	Metrics     Metrics
	Diagnostics Diagnostics
}

// Storage stores meta-info about keeping data on disk
type Storage struct {
	DataDir string
}

// Metrics stores meta-info about metrics.
type Metrics struct {
	Port                int
	NetworkMetricsTick  int
	EthereumMetricsTick int
}

// Diagnostics stores diagnostics-related configuration.
type Diagnostics struct {
	Port int
}

func init() {
	initEnvVars()
}

// initEnvVars initializes environment variables for the client configuration.
func initEnvVars() {
	if err := viper.BindEnv("ethereum.account.keyfilepassword", ethereumPasswordEnvVariable); err != nil {
		logger.Fatalf("failed to bind %s env variable", ethereumPasswordEnvVariable, err)
	}
}


// Bind the flags to the viper configuration. Viper reads configuration from
// command-line flags, environment variables and config file.
func bindFlags(flagSet *pflag.FlagSet) error {
	if err := viper.BindPFlags(flagSet); err != nil {
		return err
	}
	return nil
}


// ReadConfig reads in the configuration file at `filePath` and returns the
// valid config stored there, or an error if something fails while reading the
// file or the config is invalid in a known way.
func ReadConfig(configFilePath string) (*Config, error) {
	initializeContractAddressesAliases()

	if flagSet != nil {
		bindFlags(flagSet)
	}

	// Read configuration from a file if the config file path is set.
	if configFilePath != "" {
		if err := readConfigFile(configFilePath); err != nil {
			return nil, fmt.Errorf("unable to load config (file: [%s]): [%w]", configFilePath, err)
		}
	}

	// Unmarshal config based on loaded config file and command-line flags.
	config := &Config{}
	if err := unmarshalConfig(config); err != nil {
		return nil, fmt.Errorf("unable to unmarshal config: %w", err)
	}

	if config.Ethereum.Account.KeyFile == "" {
		return nil, fmt.Errorf(
			"missing value for ethereum key file; see ethereum section in config file or use --%s flag",
			ethereumKeyFlag,
		)
	}

	if config.LibP2P.Port == 0 {
		return nil, fmt.Errorf(
			"missing value for port; see network section in config file or use --%s flag",
			portFlag,
		)
	}

	if config.Storage.DataDir == "" {
		return nil, fmt.Errorf(
			"missing value for storage directory; see storage section in config file or use --%s flag",
			dataDirFlag,
		)
	}

	if strings.TrimSpace(config.Ethereum.Account.KeyFilePassword) == "" {
		var (
			password string
			err      error
		)
		fmt.Printf(
			"Ethereum Account Password has to be set for the configured Ethereum Key File.\n"+
				"Please set %s environment variable, or set it in the config file, or provide it in the prompt below.\n",
			EthereumPasswordEnvVariable,
		)

		for strings.TrimSpace(password) == "" {
			if password, err = readPassword("Enter Ethereum Account Password: "); err != nil {
				return nil, err
			}
		}

		config.Ethereum.Account.KeyFilePassword = password
	}

	return config, nil
}

// ReadEthereumConfig reads in the configuration file at `filePath` and returns
// its contained Ethereum config, or an error if something fails while reading
// the file.
//
// This is the same as invoking ReadConfig and reading the Ethereum property
// from the returned config, but is available for external functions that expect
// to interact solely with Ethereum and are therefore independent of the rest of
// the config structure.
func ReadEthereumConfig(filePath string) (ethereum.Config, error) {
	config, err := ReadConfig(filePath)
	if err != nil {
		return ethereum.Config{}, err
	}

	return config.Ethereum, nil
}

// readConfigFile uses viper to read configuration from a config file. The config file
// is not mandatory, if the path is
func readConfigFile(configFilePath string) error {
	// Read configuration from a file, located in `configFilePath`.
	viper.SetConfigFile(configFilePath)

	// Read configuration.
	if err := viper.ReadInConfig(); err != nil {
		return fmt.Errorf(
			"failed to read configuration from file [%s]: %w",
			configFilePath,
			err,
		)
	}

	return nil
}

// unmarshalConfig unmarshals config with viper from config file and command-line
// flags into a struct.
func unmarshalConfig(config *Config) error {
	if err := viper.Unmarshal(
		&config,
		viper.DecodeHook(
			mapstructure.ComposeDecodeHookFunc(
				mapstructure.StringToTimeDurationHookFunc(),
				mapstructure.StringToSliceHookFunc(","),
				mapstructure.TextUnmarshallerHookFunc(),
			),
		),
	); err != nil {
		return fmt.Errorf("failed to unmarshal configuration: %w", err)
	}

	return nil
}

// readPassword prompts a user to enter a password. The read password uses
// the system password reading call that helps to prevent key loggers from
// capturing the password.
func readPassword(prompt string) (string, error) {
	fmt.Print(prompt)
	bytePassword, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Print("\n")
	if err != nil {
		return "", fmt.Errorf("unable to read password, error [%s]", err)
	}

	return strings.TrimSpace(string(bytePassword)), nil
}
