:toc: macro

= RFC 2: Network Security Implementation

:icons: font
:numbered:
toc::[]


== Proposal
In this document, we describe implementation details of the Keep network 
security mechanisms meeting requirements specified in 
link:rfc-1-network-security-requirements.adoc[RFC 1]

=== Goal

Messages exchanged in the network must be attributable, maintain the 
integrity and must be optionally confidential.

=== Implementation

==== Nework topology and application-level messaging
It is important to understand the difference between the network topology 
and communication between peers on the application level. Peers connect to 
each other basis on the rules defined by the underlying P2P network protocol. 
Two peers exchanging messages on the application level does not necessarily 
need to have a direct connection with each other on the network level. It is 
possible that messages exchanged at the application level by two peers are 
relayed by other peers on the network level.

On the network level, we require all peers to prove their identity and minimum 
stake when they establish a connection with each other. All peers monitor the 
on-chain stake of peers they are connected to and are obligated to drop the 
connection with the given peer if that peer's on-chain stake dropped below the 
required minimum. This requirement enforces that only peers with a minimum 
stake are able to be a part of the network and this requirement is enforced by 
all peers individually. 

Attributability, integrity and optional confidentiality of messages are 
requirements enforced on the application level. Even if a message between two 
peers was relayed by others, this message still needs to fulfil all of those 
requirements. Since two peers exchanging messages does not necessarily need to 
have a connection on the network level with each other, they also perform an 
identity and stake check before the communication between them happens.

==== Peer identification
Each peer is identified by a static public key equal to the delegate key 
associated with an on-chain stake. There are no two peers in the network with 
the same static public key.

==== Network join protocol

Keep publishes a list of recommended bootstrap peers but every other network 
member can enable the bootstrap capability as well. The list contains addresses of 
bootstrap peers and their static public keys. Bootstrap peers are just like any 
other peers except that they also handle network join requests.

A peer wanting to connect to the network sends a network join request to one of 
the bootstrap peers. Each peer wanting to join a network needs to provide a 
proof of attestation over a minimum stake associated with peer's static public 
key, the same is required from a bootstrap peer handling the network join 
request.

The procedure is as follows:

1. Peer joining the network initiates the protocol by sending a network join 
request message containing randomly generated nonce `n_1` which is a 8-byte 
(64-bit) unsigned integer. The message is signed with the peer's static private key.
2. The bootstrap peer randomly generates nonce `n_2` which is also 8-byte unsigned 
integer and computes a challenge which is a result of calling a cryptographic hash 
function `hash` on the concatenated bytes of `n1` and `n2` (referenced as `n1 || n2`). 
The bootstrap peer sends back `n_2` and signs the message with its static private key.
3. The peer joining the network recomputes challenge from `n_1` and `n_2`, if it 
matches the challenge sent by the bootstrap peer, it answers with a message 
containing the challenge. The message is signed with peer's static private key.

```
JOINING PEER                                      BOOTSTRAP PEER

n_1 = random_nonce()
Message { n_1 } ---->
                                                  n_2 = random_nonce()
                                                  challenge = hash(n_1 || n_2)                                  
                                                  <---- Message { n_2 }
challenge = hash(n_1 || n_2)
Message {challenge} ---->
```

If all signatures have been valid and challenge response was as expected, both 
bootstrap peer and peer joining the network execute a check for an on-chain 
stake of the second party. If peer joining the network has a minimum stake, the 
bootstrap peer connects peer to the network and announces peer's 
presence. If the bootstrap peer has a minimum stake, peer joining the network 
decides to connect to the bootstrap peer and becomes a part of the network. 
Otherwise, when at least one of the parties does not have a minimum stake, the 
protocol is aborted. Peer joining the network executes the protocol again with the
next known bootstrap peer.

==== Network peer authorization protocol

When a peer went through network join protocol successfully it is connected to 
a bootstrap peer and is a full-fledged network member. It starts discovering other 
peers in the network and connects to some of those according to the strategy used 
in the network. Before peer decides to connect to any other network member, the 
same nonce, challenge, and stake check protocol must be executed between those two 
peers as it was between the peer when it was joining the network and the bootstrap 
peer. Peers decide to connect to each other only if they both went through the 
protocol successfully and proved their on-chain minimum stakes. This is a trust 
no-one strategy which allows that even a corrupted network can heal in case of a 
malicious split brain event. Just like it is with the network join protocol, nonce 
and challenge are discarded when connection protocol completed.

==== Attributability and integrity of the network messages

All messages in the network are signed with sender's private static key. Before 
any two peers start exchanging messages, they need to agree on a common nonce 
(8-byte unsigned integer) that will be used to track order of messages as well 
as to prevent replay and message-from-future attacks. The protocol is similar 
to the one used to create a challenge:

```
PEER 1                                          PEER 2

n_1 = random_nonce() 
Message { n_1 } ---->
                                                n_2 = random_nonce()
                                                nonce = hash(n_1 || n_2).toInt
                                                <---- Message { n_2 }
nonce = sha256(n_1 || n_2).toInt
```

Once peers agree on a common initial nonce they both execute a check for an 
on-chain stake of the second party. If at least one of the peers does not have a 
minimum stake, protocol is aborted and all messages from that peer are rejected.

Sender's nonce is tracked per individual peer. Each message sent from a peer 
must have a nonce greater by one from the nonce of the previous message. The 
nonce is included in a message in a way that makes it a part of the content used 
to produce a signature. 

All messages received from a given peer must contain nonces forming an ordered 
sequence. If a peer receives a message with nonce less than or equal to the most 
recent one for the given sender, the message is rejected and the sender is 
informed about that. Due to the nature of the network, some messages can be lost 
or delayed. Each peer has a cache of messages sent and received within a fixed 
time window. If a received message has a nonce greater by more than one from the 
currently expected nonce, that message is added to cache but it’s not accepted
until the gap between the expected and message’s nonce is filled. There is a 
fixed, short time limit under which the gap must be filled. If that not happens, 
the message is rejected and the sender is informed about this fact. Message 
rejected notification contains a nonce of a message that was rejected as well as 
the currently expected nonce. Sender, having the cache of messages sent in the 
fixed time window resends all the messages starting from the one with nonce 
expected by the receiver. If sender does not provide the missing messages 
within a fixed timeout, receiver drops the connection.

Sent and received messages cache window, time after a notification about 
rejecting a message is sent as well as time after connection is droped if 
expected messages were not delivered should be the same for all peers in the 
network. That's why those values are fixed and are not configurable per peer.

All peers in the network periodically execute requests to the chain in order to 
update current value of stake for each other peers they have communicated with 
so far. Stake value is cached along with the sender's nonce value. If stake 
drops down below the required minimum for some peer, that peer's nonce and stake 
are removed from the cache and all messages from that peer are rejected. Once 
the peer increases its stake so that it's above the required minimum, it must 
initialize the connection with the other peer once again in order to be able 
to communicate with it.

When peer receives a message it firsts check the signature. If it matches, then 
peer validates the nonce. If the nonce is greater by one from the nonce included 
in the previous message, then the message is accepted.

==== Message Confidentiality

Encryption is based on ephemeral keys generated individually for each protocol 
execution. Only point-to-point communication can be encrypted. 

Before the encrypted communication can happen, both involved peers generate a 
symmetric key using `Noise_KK` protocol (both initiator and responder public 
static keys are known). 

Any of the communicating peers can reveal the symmetric key in order to publicly 
publish a complaint about the other peer's message. In such case, the symmetric 
key is considered as compromised and should not be used for further 
communications.

[bibliography]
== Related Links

- Discussions on writing this document:
https://www.flowdock.com/app/cardforcoin/tech/threads/Zc_bHNDU5eNJY8JHB22NfU2a9Bk

- Noise Protocol documentation: http://noiseprotocol.org/noise.html

- Noise Protocol variations matrix:
https://latacora.singles/2018/07/18/factoring-the-noise.html

- Lighting Network Noise implementation:
https://github.com/lightningnetwork/lnd/tree/master/brontide
